#!/usr/bin/env python3
# encoding: utf8
#
# DHCPy6d DHCPv6 Daemon
#
# Copyright (C) 2009-2019 Henri Wahl <h.wahl@ifw-dresden.de>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA

import distro
import socket
import struct
import platform
import binascii
import subprocess
import subprocess
import shlex
import sys
import time
import threading
import queue
import os
import re
import socketserver
import traceback
import copy
import logging
import logging.handlers
import pwd
import grp
import time
import dns.query
import dns.resolver
import dns.reversename

# access /usr/share/pyshared on Debian
# http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=715010
if distro.id() == 'debian':
    sys.path[0:0] = ['/usr/share/pyshared']

from dhcpy6.helpers import *
from dhcpy6.constants import *
from dhcpy6.config import *
from dhcpy6.storage import *

# create and read config file
cfg = Config()

# if nameserver is given create resolver
if len(cfg.NAMESERVER) > 0:
    # default nameservers for DNS queries
    resolver_query = dns.resolver.Resolver()
    resolver_query.nameservers = cfg.NAMESERVER

# RNDC Key for DNS updates from ISC Bind /etc/rndc.key
if cfg.DNS_UPDATE:
    import dns.update
    import dns.tsigkeyring

    Keyring = dns.tsigkeyring.from_text({cfg.DNS_RNDC_KEY : cfg.DNS_RNDC_SECRET})

    # resolver for DNS updates
    resolver_update = dns.resolver.Resolver()
    resolver_update.nameservers = [cfg.DNS_UPDATE_NAMESERVER]

# Logging
log = logging.getLogger('dhcpy6d')
if cfg.LOG:
    formatter = logging.Formatter('%(asctime)s %(name)s %(levelname)s %(message)s')
    log.setLevel(logging.__dict__[cfg.LOG_LEVEL])
    if cfg.LOG_FILE != '':
        os.chown(cfg.LOG_FILE, pwd.getpwnam(cfg.USER).pw_uid, grp.getgrnam(cfg.GROUP).gr_gid)
        log_handler = logging.handlers.WatchedFileHandler(cfg.LOG_FILE)
        log_handler.setFormatter(formatter)
        log.addHandler(log_handler)
    # std err console output
    if cfg.LOG_CONSOLE:
        log_handler = logging.StreamHandler()
        log_handler.setFormatter(formatter)
        log.addHandler(log_handler)
    if cfg.LOG_SYSLOG:
        # time should be added by syslog daemon
        hostname = socket.gethostname().split('.')[0]
        formatter = logging.Formatter(hostname + ' %(name)s %(levelname)s %(message)s')
        # if /socket/file is given use this as addres
        if cfg.LOG_SYSLOG_DESTINATION.startswith('/') == True:
            destination = cfg.LOG_SYSLOG_DESTINATION
        # if host and port are defined use them...
        elif cfg.LOG_SYSLOG_DESTINATION.count(':') == 1:
            destination = tuple(cfg.LOG_SYSLOG_DESTINATION.split(':'))
        # ...otherwise add port 514 to given host address
        else:
            destination = (cfg.LOG_SYSLOG_DESTINATION, 514)
        log_handler = logging.handlers.SysLogHandler(address=destination,
                      facility=logging.handlers.SysLogHandler.__dict__['LOG_' + cfg.LOG_SYSLOG_FACILITY])
        log_handler.setFormatter(formatter)
        log.addHandler(log_handler)

# dictionary to store transactions - key is transaction ID, value a transaction object
Transactions = dict()

# collected MAC addresses from clients, mapping to link local IPs
CollectedMACs = dict()

# queues for queries
configquery_queue = queue.Queue()
configanswer_queue = queue.Queue()
volatilequery_queue = queue.Queue()
volatileanswer_queue = queue.Queue()

# queue for dns actualization
dnsquery_queue = queue.Queue()

# queue for executing some script to modify routes after delegating prefixes
route_queue = queue.Queue()

# attempt to log connections and count them to find out which clients do silly crazy brute force
requests = dict()
requests_blacklist = dict()

# global time variable, synchronized by TimerThread
timer = int(time.time())

# save OS
OS = platform.system()
if 'BSD' in OS:
    OS = 'BSD'

# platform-dependant neighbor cache call
# every platform has its different output
# dev, llip and mac are positions of output of call
# len is minimal length a line has to have to be evaluable
#
# update: has been different to Linux which now access neighbor cache natively
NC = { 'BSD': { 'call' : '/usr/sbin/ndp -a -n',
                'dev'  : 2,
                'llip' : 0,
                'mac'  : 1,
                'len'  : 3},
       'Darwin': { 'call' : '/usr/sbin/ndp -a -n',
                   'dev'  : 2,
                   'llip' : 0,
                   'mac'  : 1,
                   'len'  : 3}
            }

# libc access via ctypes, needed for interface handling, get it by helpers.get_libc()
# obsolete in Python 3
# LIBC = get_libc()

# index IF name > number, gets filled in UDPMulticastIPv6
IF_NAME = dict()
# index IF number > name
IF_NUMBER = dict()

# IA_NA, IA_TA and IA_PD Options referred here in handler
IA_OPTIONS = (3, 4, 25)

# options to be ignored when logging
IGNORED_LOG_OPTIONS = ['OptionsRaw', 'Client', 'ClientConfigDB', 'Timestamp', 'DUIDLLAddress', 'DUIDType', 'IAT1', 'IAT2', 'IP6_old', 'LLIP_old']

# empty options string test
EMPTY_OPTIONS = [None, False, '', []]

# dummy IAID for transactions
DUMMY_IAID = '00000000'

# dummy MAC for transactions
DUMMY_MAC = '00:00:00:00:00:00'

# store
# because of thread trouble there should not be too much db connections at once
# so we need to use the queryqueue way - subject to change
# source of configuration of hosts
# use client configuration only if needed
if cfg.STORE_CONFIG:
    if cfg.STORE_CONFIG == 'file':
        configstore = Textfile(cfg, configquery_queue, configanswer_queue, Transactions, CollectedMACs)
    if cfg.STORE_CONFIG == 'mysql':
        configstore = DBMySQL(cfg, configquery_queue, configanswer_queue, Transactions, CollectedMACs)
    if cfg.STORE_CONFIG == 'postgresql':
        configstore = DBPostgreSQL(cfg, configquery_queue, configanswer_queue, Transactions, CollectedMACs)
    if cfg.STORE_CONFIG == 'sqlite':
        configstore = SQLite(cfg, configquery_queue, configanswer_queue, Transactions, CollectedMACs, storage_type='config')
else:
    # dummy configstore if no client config is needed
    configstore = Store(cfg, configquery_queue, configanswer_queue, Transactions, CollectedMACs)
    # 'none' store is always connected
    configstore.connected = True

# storage for changing data like leases, LLIPs, DUIDs etc.
if cfg.STORE_VOLATILE == 'mysql':
    volatilestore = DBMySQL(cfg, volatilequery_queue, volatileanswer_queue, Transactions, CollectedMACs)
if cfg.STORE_VOLATILE == 'postgresql':
    volatilestore = DBPostgreSQL(cfg, volatilequery_queue, volatileanswer_queue, Transactions, CollectedMACs)
if cfg.STORE_VOLATILE == 'sqlite':
    volatilestore = SQLite(cfg, volatilequery_queue, volatileanswer_queue, Transactions, CollectedMACs, storage_type='volatile')

# do not start if no database connection exists
if not configstore.connected:
    print('\nConfiguration database is not connected!\n')
    sys.exit(1)
if not volatilestore.connected:
    print('\nDatabase for volatile data is not connected!\n')
    sys.exit(1)


def build_client(transaction_id):
    """
        builds client object of client config and transaction data
        checks if filters apply
        check if lease is still valid for RENEW and REBIND answers
        check if invalid addresses need to get deleted with lifetime 0
    """
    try:
        # create client object
        client = Client()

        # configuration from client deriving from general config or filters - defaults to none
        client_config = None

        # list to collect filtered client information
        # if there are more than one entries that do not match the class is not uniquely identified
        filtered_class = dict()

        # check if there are identification attributes of any class - classes are sorted by filter types
        for f in cfg.FILTERS:
            # look into all classes and their filters
            for c in cfg.FILTERS[f]:
                # check further only if class applies to interface
                if Transactions[transaction_id].Interface in c.INTERFACE:
                    # MACs
                    if c.FILTER_MAC != '':
                        pattern = re.compile(c.FILTER_MAC)
                        # if mac filter fits client mac address add client config
                        if len(pattern.findall(Transactions[transaction_id].MAC)) > 0:
                            client_config = configstore.get_client_config(hostname=Transactions[transaction_id].Hostname,
                                                                          mac=[Transactions[transaction_id].MAC],
                                                                          duid=Transactions[transaction_id].DUID,
                                                                          aclass=c.NAME)
                            # add classname to dictionary - if there are more than one entry classes do not match
                            # and thus are invalid
                            filtered_class[c.NAME] = c
                    # DUIDs
                    if c.FILTER_DUID != '':
                        pattern = re.compile(c.FILTER_DUID)
                        # if duid filter fits client duid address add client config
                        if len(pattern.findall(Transactions[transaction_id].DUID)) > 0:
                            client_config = configstore.get_client_config(hostname=Transactions[transaction_id].Hostname,
                                                                          mac=[Transactions[transaction_id].MAC],
                                                                          duid=Transactions[transaction_id].DUID,
                                                                          aclass=c.NAME)
                            # see above
                            filtered_class[c.NAME] = c
                    # HOSTNAMEs
                    if c.FILTER_HOSTNAME != '':
                        pattern = re.compile(c.FILTER_HOSTNAME)
                        # if hostname filter fits client hostname address add client config
                        if len(pattern.findall(Transactions[transaction_id].Hostname)) > 0:
                            client_config = configstore.get_client_config(hostname=Transactions[transaction_id].Hostname,
                                                                          mac=[Transactions[transaction_id].MAC],
                                                                          duid=Transactions[transaction_id].DUID,
                                                                          aclass=c.NAME)
                            # see above
                            filtered_class[c.NAME] = c

        # if there are more than 1 different classes matching for the client they are not valid
        if len(filtered_class) != 1:
            client_config = None

        # if filters did not get a result try it the hard way
        if client_config == None:
            # check all given identification criteria - if they all match each other the client is identified
            id_attributes = list()

            # get client config that most probably seems to fit
            configstore.build_config_from_db(transaction_id)

            # check every attribute which is required
            # depending on identificaton mode empty results are ignored or considered
            # finally all attributes are grouped in sets and for a correctly identified host
            # only one entry should appear at the end
            for i in cfg.IDENTIFICATION:
                if i == 'mac':
                    # get all MACs for client from config
                    macs = configstore.get_client_config_by_mac(transaction_id)
                    if macs:
                        macs = set(macs)
                        id_attributes.append('macs')
                    elif cfg.IDENTIFICATION_MODE == 'match_all':
                        macs = set()
                        id_attributes.append('macs')

                if i == 'duid':
                    duids = configstore.get_client_config_by_duid(transaction_id)
                    if duids:
                        duids = set(duids)
                        id_attributes.append('duids')
                    elif cfg.IDENTIFICATION_MODE == 'match_all':
                        duids = set()
                        id_attributes.append('duids')

                if i == 'hostname':
                    hostnames = configstore.get_client_config_by_hostname(transaction_id)
                    if hostnames:
                        hostnames = set(hostnames)
                        id_attributes.append('hostnames')
                    elif cfg.IDENTIFICATION_MODE == 'match_all':
                        hostnames = set()
                        id_attributes.append('hostnames')

            # get intersection of all sets of identifying attributes - even the empty ones
            if len(id_attributes) > 0:
                client_config = set.intersection(eval('&'.join(id_attributes)))

                # if exactly one client has been identified use that config
                if len(client_config) == 1:
                    # reuse client_config, grab it out of the set
                    client_config = client_config.pop()
                else:
                    # in case there is no client config we should maybe log this?
                    client_config = None
            else:
                client_config = None

        # If client gave some addresses for RENEW or REBIND consider them
        if Transactions[transaction_id].LastMessageReceivedType in (5, 6) and\
            not (len(Transactions[transaction_id].Addresses) == 0 and \
                 len(Transactions[transaction_id].Prefixes) == 0):
            if not client_config == None:
                # give client hostname
                client.Hostname = client_config.HOSTNAME
                client.Class = client_config.CLASS
                # apply answer type of client to transaction - useful if no answer or no address available is configured
                Transactions[transaction_id].Answer = cfg.CLASSES[client.Class].ANSWER
            else:
                # use default class if host is unknown
                client.Hostname = Transactions[transaction_id].Hostname
                client.Class = 'default_' + Transactions[transaction_id].Interface
                # apply answer type of client to transaction - useful if no answer or no address available is configured
                Transactions[transaction_id].Answer = cfg.CLASSES[client.Class].ANSWER

            if 'addresses' in cfg.CLASSES[client.Class].ADVERTISE and \
                (3 or 4) in Transactions[transaction_id].IA_Options:
                for address in Transactions[transaction_id].Addresses:
                    # check_lease returns hostname, address, type, category, ia_type, class, preferred_until of leased address
                    answer = volatilestore.check_lease(address, transaction_id)
                    if answer:
                        if len(answer) > 0:
                            for item in answer:
                                a = dict(list(zip(('hostname', 'address', 'type', 'category', 'ia_type', 'class', 'preferred_until'), item)))
                                # if lease exists but no configured client set class to default
                                if client_config == None:
                                    client.Hostname = Transactions[transaction_id].Hostname
                                    client.Class = 'default_' + Transactions[transaction_id].Interface
                                # check if address type of lease still exists in configuration
                                # and if request interface matches that of class
                                if a['class'] in cfg.CLASSES and client.Class == a['class'] and\
                                   Transactions[transaction_id].Interface in cfg.CLASSES[client.Class].INTERFACE:
                                    # type of address must be defined in addresses for this class
                                    # or fixed/dns - in which case it is not class related
                                    if a['type'] in cfg.CLASSES[a['class']].ADDRESSES or a['type'] in ['fixed']:
                                        # flag for lease usage
                                        use_lease = True
                                        # test lease validity against address prototype pattern only if not fixed or from DNS
                                        if not a['category'] in ['fixed', 'dns']:
                                            # test if address matches pattern
                                            for i in range(len(address)):
                                                if address[i] != cfg.ADDRESSES[a['type']].PROTOTYPE[i] and \
                                                   cfg.ADDRESSES[a['type']].PROTOTYPE[i] != 'x':
                                                    use_lease = False
                                                    break
                                        elif a['category'] == 'fixed' and not client_config.ADDRESS == None:
                                            if not address in client_config.ADDRESS:
                                                use_lease = False
                                        elif a['category'] == 'dns':
                                            use_lease = False

                                        # only use lease if it still matches prototype
                                        if use_lease == True:
                                            # when category is range, test if it still applies
                                            if a['category'] == 'range':
                                                # borrowed from parse_pattern_address to find out if lease is still in a meanwhile maybe changed range
                                                frange, trange = cfg.ADDRESSES[a['type']].RANGE.split('-')

                                                # correct possible misconfiguration
                                                if len(frange)<4:
                                                    frange ='0'*(4-len(frange)) + frange
                                                if len(trange)<4:
                                                    trange ='0'*(4-len(trange)) + trange
                                                if frange > trange:
                                                    frange, trange = trange, frange
                                                # if lease is still inside range boundaries use it
                                                if frange <= address[28:].lower() < trange:
                                                    # build IA partly of leases db, partly of config db
                                                    ia = Address(address=a['address'],
                                                                 atype=a['type'],
                                                                 preferred_lifetime=cfg.ADDRESSES[a['type']].PREFERRED_LIFETIME,
                                                                 valid_lifetime=cfg.ADDRESSES[a['type']].VALID_LIFETIME,
                                                                 category=a['category'],
                                                                 ia_type=a['ia_type'],
                                                                 aclass=a['class'],
                                                                 dns_update=cfg.ADDRESSES[a['type']].DNS_UPDATE,
                                                                 dns_zone=cfg.ADDRESSES[a['type']].DNS_ZONE,
                                                                 dns_rev_zone=cfg.ADDRESSES[a['type']].DNS_REV_ZONE,
                                                                 dns_ttl=cfg.ADDRESSES[a['type']].DNS_TTL)
                                                    client.Addresses.append(ia)

                                            # de-preferred random address has to be deleted and replaced
                                            elif a['category'] == 'random' and timer > a['preferred_until']:
                                                # create new random address if old one is depreferred
                                                random_address = parse_pattern_address(cfg.ADDRESSES[a['type']], client_config, transaction_id)
                                                # create new random address if old one is de-preferred
                                                # do not wait until it is invalid
                                                if not random_address == None:
                                                    ia = Address(address=random_address, ia_type=cfg.ADDRESSES[a['type']].IA_TYPE,
                                                                 preferred_lifetime=cfg.ADDRESSES[a['type']].PREFERRED_LIFETIME,
                                                                 valid_lifetime=cfg.ADDRESSES[a['type']].VALID_LIFETIME,
                                                                 category='random',
                                                                 aclass=cfg.ADDRESSES[a['type']].CLASS,
                                                                 atype=cfg.ADDRESSES[a['type']].TYPE,
                                                                 dns_update=cfg.ADDRESSES[a['type']].DNS_UPDATE,
                                                                 dns_zone=cfg.ADDRESSES[a['type']].DNS_ZONE,
                                                                 dns_rev_zone=cfg.ADDRESSES[a['type']].DNS_REV_ZONE,
                                                                 dns_ttl=cfg.ADDRESSES[a['type']].DNS_TTL)
                                                    client.Addresses.append(ia)
                                                    # set de-preferred address invalid
                                                    client.Addresses.append(Address(address=a['address'], valid=False,
                                                                                    preferred_lifetime=0,
                                                                                    valid_lifetime=0))

                                            else:
                                                # build IA partly of leases db, partly of config db
                                                ia = Address(address=a['address'],
                                                             atype=a['type'],
                                                             preferred_lifetime=cfg.ADDRESSES[a['type']].PREFERRED_LIFETIME,
                                                             valid_lifetime=cfg.ADDRESSES[a['type']].VALID_LIFETIME,
                                                             category=a['category'],
                                                             ia_type=a['ia_type'],
                                                             aclass=a['class'],
                                                             dns_update=cfg.ADDRESSES[a['type']].DNS_UPDATE,
                                                             dns_zone=cfg.ADDRESSES[a['type']].DNS_ZONE,
                                                             dns_rev_zone=cfg.ADDRESSES[a['type']].DNS_REV_ZONE,
                                                             dns_ttl=cfg.ADDRESSES[a['type']].DNS_TTL)
                                                client.Addresses.append(ia)

                # important indent here, has to match for...addresses-loop!
                # look for addresses in transaction that are invalid and add them
                # to client addresses with flag invalid and a RFC-compliant lifetime of 0
                for a in set(Transactions[transaction_id].Addresses).difference([decompress_ip6(x.ADDRESS) for x in client.Addresses]):
                    client.Addresses.append(Address(address=a,
                                                    valid=False,
                                                    preferred_lifetime=0,
                                                    valid_lifetime=0))

            if 'prefixes' in cfg.CLASSES[client.Class].ADVERTISE and \
               25 in Transactions[transaction_id].IA_Options:
                for prefix in Transactions[transaction_id].Prefixes:
                    # split prefix of prefix from length, separated by /
                    prefix_prefix, prefix_length = split_prefix(prefix)

                    # check_prefix returns hostname, prefix, length, type, category, class, preferred_until of leased address
                    answer = volatilestore.check_prefix(prefix_prefix, prefix_length, transaction_id)

                    if answer:
                        if len(answer) > 0:
                            for item in answer:
                                p = dict(list(zip(('hostname', 'prefix', 'length', 'type', 'category', 'class', 'preferred_until'), item)))
                                # if lease exists but no configured client set class to default
                                if client_config == None:
                                    client.Hostname = Transactions[transaction_id].Hostname
                                    client.Class = 'default_' + Transactions[transaction_id].Interface
                                # check if address type of lease still exists in configuration
                                # and if request interface matches that of class
                                if p['class'] in cfg.CLASSES and client.Class == p['class'] and\
                                   Transactions[transaction_id].Interface in cfg.CLASSES[client.Class].INTERFACE:
                                    # type of address must be defined in addresses for this class
                                    # or fixed/dns - in which case it is not class related
                                    if p['type'] in cfg.CLASSES[p['class']].PREFIXES:
                                        # flag for lease usage
                                        use_lease = True
                                        # test if prefix matches pattern
                                        for i in range(len(prefix_prefix)):
                                            if prefix_prefix[i] != cfg.PREFIXES[p['type']].PROTOTYPE[i] and \
                                               cfg.PREFIXES[p['type']].PROTOTYPE[i] != 'x':
                                                use_lease = False
                                                break
                                        # only use prefix if it still matches prototype
                                        if use_lease == True:
                                            # when category is range, test if it still applies
                                            if p['category'] == 'range':
                                                # borrowed from parse_pattern_prefix to find out if lease is still in a meanwhile maybe changed range
                                                frange, trange = cfg.PREFIXES[p['type']].RANGE.split('-')

                                                # correct possible misconfiguration
                                                if len(frange)<4:
                                                    frange ='0'*(4-len(frange)) + frange
                                                if len(trange)<4:
                                                    trange ='0'*(4-len(trange)) + trange
                                                if frange > trange:
                                                    frange, trange = trange, frange

                                                # contrary to addresses the prefix $range$ part of the pattern is expected somewhere at the left part of the pattern
                                                # here the 128 Bit sum up to 32 characters in address/prefix string so prefix_range_index has to be calculated
                                                # as first character of range part of prefix - assuming steps of width 4
                                                prefix_range_index = int(cfg.PREFIXES[p['type']].LENGTH) / 4 - 4
                                                # prefix itself has a prefix - the first part of the prefix pattern
                                                prefix_prefix = decompress_ip6(p['prefix'].replace('$range$', '0000'))[:prefix_range_index + 4]

                                                # if lease is still inside range boundaries use it
                                                if frange <= prefix_prefix[prefix_range_index:prefix_range_index + 4].lower() < trange:
                                                    # build IA partly of leases db, partly of config db
                                                    ia = Prefix(prefix=p['prefix'],
                                                                length=p['length'],
                                                                ptype=p['type'],
                                                                preferred_lifetime=cfg.PREFIXES[p['type']].PREFERRED_LIFETIME,
                                                                valid_lifetime=cfg.PREFIXES[p['type']].VALID_LIFETIME,
                                                                category=p['category'],
                                                                pclass=p['class'],
                                                                route_link_local=cfg.PREFIXES[p['type']].ROUTE_LINK_LOCAL)
                                                    client.Prefixes.append(ia)

                # important indent here, has to match for...prefixes-loop!
                # look for prefixes in transaction that are invalid and add them
                # to client prefixes with flag invalid and a RFC-compliant lifetime of 0
                if len(client.Prefixes) > 0:
                    for p in set(Transactions[transaction_id].Prefixes).difference([decompress_prefix(x.PREFIX, x.LENGTH) for x in client.Prefixes]):
                        prefix, length = split_prefix(p)
                        client.Prefixes.append(Prefix(prefix=prefix,
                                                      length=length,
                                                      valid=False,
                                                      preferred_lifetime=0,
                                                      valid_lifetime=0))
                        del(prefix, length)

            return client

        # build IA addresses from config - fixed ones and dynamic
        if client_config != None:
            # give client hostname + class
            client.Hostname = client_config.HOSTNAME
            client.Class = client_config.CLASS
            # apply answer type of client to transaction - useful if no answer or no address available is configured
            Transactions[transaction_id].Answer = cfg.CLASSES[client.Class].ANSWER
            # continue only if request interface matches class interfaces
            if Transactions[transaction_id].Interface in cfg.CLASSES[client.Class].INTERFACE:
                # if fixed addresses are given build them
                if not client_config.ADDRESS == None:
                    for address in client_config.ADDRESS:
                        if len(address) > 0:
                            # fixed addresses are assumed to be non-temporary
                            #
                            # todo: lifetime of address should be set by config too
                            #
                            ia = Address(address=address,
                                         ia_type='na',
                                         preferred_lifetime=cfg.PREFERRED_LIFETIME,
                                         valid_lifetime=cfg.VALID_LIFETIME,
                                         category='fixed',
                                         aclass='fixed',
                                         atype='fixed')

                            client.Addresses.append(ia)

                if not client_config.CLASS == '':
                    # add all addresses which belong to that class
                    for address in cfg.CLASSES[client_config.CLASS].ADDRESSES:
                        # addresses of category 'dns' will be searched in DNS
                        if cfg.ADDRESSES[address].CATEGORY == 'dns':
                            a = get_ip_from_dns(client.Hostname)
                        else:
                            a = parse_pattern_address(cfg.ADDRESSES[address], client_config, transaction_id)
                        # in case range has been exceeded a will be None
                        if a:
                            ia = Address(address=a,
                                         ia_type=cfg.ADDRESSES[address].IA_TYPE,
                                         preferred_lifetime=cfg.ADDRESSES[address].PREFERRED_LIFETIME,
                                         valid_lifetime=cfg.ADDRESSES[address].VALID_LIFETIME,
                                         category=cfg.ADDRESSES[address].CATEGORY,
                                         aclass=cfg.ADDRESSES[address].CLASS,
                                         atype=cfg.ADDRESSES[address].TYPE,
                                         dns_update=cfg.ADDRESSES[address].DNS_UPDATE,
                                         dns_zone=cfg.ADDRESSES[address].DNS_ZONE,
                                         dns_rev_zone=cfg.ADDRESSES[address].DNS_REV_ZONE,
                                         dns_ttl=cfg.ADDRESSES[address].DNS_TTL)
                            client.Addresses.append(ia)

                    # add all bootfiles which belong to that class
                    for bootfile in cfg.CLASSES[client_config.CLASS].BOOTFILES:
                        client_architecture = cfg.BOOTFILES[bootfile].CLIENT_ARCHITECTURE
                        user_class = cfg.BOOTFILES[bootfile].USER_CLASS

                        # check if transaction attributes matches the bootfile defintion
                        if (not client_architecture or \
                                Transactions[transaction_id].ClientArchitecture == client_architecture or \
                                Transactions[transaction_id].KnownClientArchitecture == client_architecture) and \
                           (not user_class or \
                                Transactions[transaction_id].UserClass == user_class):
                            client.Bootfiles.append(cfg.BOOTFILES[bootfile])


                    if 'prefixes' in cfg.CLASSES[client_config.CLASS].ADVERTISE and \
                       25 in Transactions[transaction_id].IA_Options:
                        for prefix in cfg.CLASSES[client_config.CLASS].PREFIXES:
                            p = parse_pattern_prefix(cfg.PREFIXES[prefix], client_config, transaction_id)
                            # in case range has been exceeded p will be None
                            if p:
                                ia_pd = Prefix(prefix=p,
                                               length=cfg.PREFIXES[prefix].LENGTH,
                                               preferred_lifetime=cfg.PREFIXES[prefix].PREFERRED_LIFETIME,
                                               valid_lifetime=cfg.PREFIXES[prefix].VALID_LIFETIME,
                                               category=cfg.PREFIXES[prefix].CATEGORY,
                                               pclass=cfg.PREFIXES[prefix].CLASS,
                                               ptype=cfg.PREFIXES[prefix].TYPE,
                                               route_link_local=cfg.PREFIXES[prefix].ROUTE_LINK_LOCAL)
                                client.Prefixes.append(ia_pd)

                if client_config.ADDRESS == client_config.CLASS == '':
                    # use default class if no class or address is given
                    for address in cfg.CLASSES['default_' + Transactions[transaction_id].Interface].ADDRESSES:
                        client.Class = 'default_' + Transactions[transaction_id].Interface
                        # addresses of category 'dns' will be searched in DNS
                        if cfg.ADDRESSES[address].CATEGORY == 'dns':
                            a = get_ip_from_dns(client.Hostname)
                        else:
                            a = parse_pattern_address(cfg.ADDRESSES[address], client_config, transaction_id)
                        if a:
                            ia = Address(address=a, ia_type=cfg.ADDRESSES[address].IA_TYPE,
                                         preferred_lifetime=cfg.ADDRESSES[address].PREFERRED_LIFETIME,
                                         valid_lifetime=cfg.ADDRESSES[address].VALID_LIFETIME,
                                         category=cfg.ADDRESSES[address].CATEGORY,
                                         aclass=cfg.ADDRESSES[address].CLASS,
                                         atype=cfg.ADDRESSES[address].TYPE,
                                         dns_update=cfg.ADDRESSES[address].DNS_UPDATE,
                                         dns_zone=cfg.ADDRESSES[address].DNS_ZONE,
                                         dns_rev_zone=cfg.ADDRESSES[address].DNS_REV_ZONE,
                                         dns_ttl=cfg.ADDRESSES[address].DNS_TTL)
                            client.Addresses.append(ia)

                    for bootfile in cfg.CLASSES['default_' + Transactions[transaction_id].Interface].BOOTFILES:
                        client_architecture = bootfile.CLIENT_ARCHITECTURE
                        user_class = bootfile.USER_CLASS

                        # check if transaction attributes matches the bootfile defintion
                        if (not client_architecture or \
                                Transactions[transaction_id].ClientArchitecture == client_architecture or \
                                Transactions[transaction_id].KnownClientArchitecture == client_architecture) and \
                           (not user_class or \
                                Transactions[transaction_id].UserClass == user_class):
                            client.Bootfiles.append(bootfile)
        else:
            # use default class if host is unknown
            client.Hostname = Transactions[transaction_id].Hostname
            client.Class = 'default_' + Transactions[transaction_id].Interface
            # apply answer type of client to transaction - useful if no answer or no address available is configured
            Transactions[transaction_id].Answer = cfg.CLASSES[client.Class].ANSWER

            if 'addresses' in cfg.CLASSES['default_' + Transactions[transaction_id].Interface].ADVERTISE and \
                (3 or 4) in Transactions[transaction_id].IA_Options:
                for address in cfg.CLASSES['default_' + Transactions[transaction_id].Interface].ADDRESSES:
                    # addresses of category 'dns' will be searched in DNS
                    if cfg.ADDRESSES[address].CATEGORY == 'dns':
                        a = get_ip_from_dns(client.Hostname)
                    else:
                        a = parse_pattern_address(cfg.ADDRESSES[address], client, transaction_id)
                    if a:
                        ia = Address(address=a, ia_type=cfg.ADDRESSES[address].IA_TYPE,
                                     preferred_lifetime=cfg.ADDRESSES[address].PREFERRED_LIFETIME,
                                     valid_lifetime=cfg.ADDRESSES[address].VALID_LIFETIME,
                                     category=cfg.ADDRESSES[address].CATEGORY,
                                     aclass=cfg.ADDRESSES[address].CLASS,
                                     atype=cfg.ADDRESSES[address].TYPE,
                                     dns_update=cfg.ADDRESSES[address].DNS_UPDATE,
                                     dns_zone=cfg.ADDRESSES[address].DNS_ZONE,
                                     dns_rev_zone=cfg.ADDRESSES[address].DNS_REV_ZONE,
                                     dns_ttl=cfg.ADDRESSES[address].DNS_TTL)
                        client.Addresses.append(ia)

            if 'prefixes' in cfg.CLASSES['default_' + Transactions[transaction_id].Interface].ADVERTISE and \
                25 in Transactions[transaction_id].IA_Options:

                for prefix in cfg.CLASSES['default_' + Transactions[transaction_id].Interface].PREFIXES:
                    p = parse_pattern_prefix(cfg.PREFIXES[prefix], client_config, transaction_id)
                    # in case range has been exceeded p will be None
                    if p:
                        ia_pd = Prefix(prefix=p,
                                       length=cfg.PREFIXES[prefix].LENGTH,
                                       preferred_lifetime=cfg.PREFIXES[prefix].PREFERRED_LIFETIME,
                                       valid_lifetime=cfg.PREFIXES[prefix].VALID_LIFETIME,
                                       category=cfg.PREFIXES[prefix].CATEGORY,
                                       pclass=cfg.PREFIXES[prefix].CLASS,
                                       ptype=cfg.PREFIXES[prefix].TYPE,
                                       route_link_local=cfg.PREFIXES[prefix].ROUTE_LINK_LOCAL)
                        client.Prefixes.append(ia_pd)

        return client

    except Exception as err:
        traceback.print_exc(file=sys.stdout)
        sys.stdout.flush()
        log.error('build_client(): ' + str(err))
        return None


def parse_pattern_address(address, client_config, transaction_id):
    """
        parse address pattern and replace variables with current values
    """
    # parse all pattern parts
    a = address.PATTERN

    # if dhcpy6d got a new (mostly dynamic) prefix at start insert it here
    if not cfg.PREFIX == None:
        a = a.replace('$prefix$', cfg.PREFIX)

    # check different client address categories - to be extended!
    if address.CATEGORY == 'mac':
        macraw = ''.join(Transactions[transaction_id].MAC.split(':'))
        a = a.replace('$mac$', ':'.join((macraw[0:4], macraw[4:8], macraw[8:12])))
    elif address.CATEGORY == 'eui64':
        # https://tools.ietf.org/html/rfc4291#section-2.5.1
        mac = Transactions[transaction_id].MAC
        a = a.replace('$eui64$', convert_mac_to_eui64(mac))
    elif address.CATEGORY in ['fixed', 'dns']:
        # No patterns for fixed address, let's bail
        return None
    elif address.CATEGORY == 'id':
        # if there is an ID build address
        if str(client_config.ID) != '':
            a = a.replace('$id$', str(client_config.ID))
        else:
            return None
    elif address.CATEGORY == 'random':
        # first check if address already has been advertised
        advertised_address = volatilestore.check_advertised_lease(transaction_id, category='random', atype=address.TYPE)
        # when address already has been advertised for this client use it
        if advertised_address:
            a = advertised_address
        else:
            ra = str(hex(random.getrandbits(64)))[2:][:-1]
            ra = ':'.join((ra[0:4], ra[4:8], ra[8:12], ra[12:16]))
            # subject to change....
            a = a.replace('$random64$', ra)
    elif address.CATEGORY == 'range':
        frange, trange = address.RANGE.split('-')
        if len(frange)<4:
            frange ='0'*(4-len(frange)) + frange
        if len(trange)<4:
            trange ='0'*(4-len(trange)) + trange
        if frange > trange:
            frange, trange = trange, frange

        # expecting range-range at the last octet, 'prefix' means the first seven octets here
        # - is just shorter than the_first_seven_octets
        prefix = decompress_ip6(a.replace('$range$', '0000'))[:28]

        # the following steps are done to find a collision-free lease in given range
        # check if address already has been advertised - important for REPLY after SOLICIT-ADVERTISE-REQUEST
        advertised_address = volatilestore.check_advertised_lease(transaction_id, category='range', atype=address.TYPE)
        # when address already has been advertised for this client use it
        if advertised_address:
            a = advertised_address
        else:
            # check if requesting client still has an active lease that could be reused
            lease = volatilestore.get_range_lease_for_recycling(prefix=prefix, frange=frange, trange=trange,\
                                                                duid=Transactions[transaction_id].DUID,\
                                                                mac=Transactions[transaction_id].MAC)
            # the found lease has to be in range - important after changed range boundaries
            if not lease is None and frange <= lease[28:].lower() <= trange:
                a = ':'.join((lease[0:4], lease[4:8], lease[8:12], lease[12:16],\
                              lease[16:20], lease[20:24], lease[24:28], lease[28:32]))
            else:
                # get highest active lease to increment address about 1
                lease = volatilestore.get_highest_range_lease(prefix=prefix, frange=frange, trange=trange)
                # check if highest active lease still fits into range
                if not lease is None and frange <= lease[28:].lower() < trange:
                    # if highest lease + 1 would not fit range limit is reached
                    if lease[28:].lower() >= trange:
                        # try to get one of the inactive old leases
                        lease = volatilestore.get_oldest_inactive_range_lease(prefix=prefix, frange=frange, trange=trange)
                        if lease is None:
                            # if none is available limit is reached and nothing returned
                            log.critical('Address space %s[%s-%s] exceeded' % (prefix, frange,trange))
                            return None
                        else:
                            # if lease is OK use it
                            a = lease
                    else:
                        # otherwise increase current maximum range limit by 1
                        a = a.replace('$range$', str(hex(int(lease[28:], 16) + 1)).split('x')[1])
                else:
                    # if there is no lease yet or range limit is reached try to reactivate an old inactive lease
                    lease = volatilestore.get_oldest_inactive_range_lease(prefix=prefix, frange=frange, trange=trange)
                    if lease is None:
                        # if there are no leases stored yet initiate lease storage
                        # this will be done only once - the first time if there is no other lease yet
                        # so it is safe to start from frange
                        if volatilestore.check_number_of_leases(prefix, frange, trange) <= 1:
                            a = a.replace('$range$', frange)
                        else:
                            # if none is available limit is reached and nothing returned
                            log.critical('Address space %s[%s-%s] exceeded' % (prefix, frange,trange))
                            return None
                    else:
                        # if there is a lease it might be used
                        a = lease

    return decompress_ip6(a)


def parse_pattern_prefix(pattern, client_config, transaction_id):
    """
        parse address pattern and replace variables with current values
    """
    # parse all pattern parts
    p = pattern.PATTERN

    # if dhcpy6d got a new (mostly dynamic) prefix at start insert it here
    p = p.replace('$prefix$', cfg.PREFIX)

    if pattern.CATEGORY == 'id':
        # if there is an ID build address
        if str(client_config.ID) != '':
            p = p.replace('$id$', str(client_config.ID))
        else:
            return None

    elif pattern.CATEGORY == 'range':
        frange, trange = pattern.RANGE.split('-')
        if len(frange)<4:
            frange ='0'*(4-len(frange)) + frange
        if len(trange)<4:
            trange ='0'*(4-len(trange)) + trange
        if frange > trange:
            frange, trange = trange, frange

        # contrary to addresses the prefix $range$ part of the pattern is expected somewhere at the left part of the pattern
        # here the 128 Bit sum up to 32 characters in address/prefix string so prefix_range_index has to be calculated
        # as first character of range part of prefix - assuming steps of width 4
        prefix_range_index = int(pattern.LENGTH)/4-4
        # prefix itself has a prefix - the first part of the prefix pattern
        prefix_prefix = decompress_ip6(p.replace('$range$', '0000'))[:prefix_range_index]

        # the following steps are done to find a collision-free lease in given range
        # check if address already has been advertised - important for REPLY after SOLICIT-ADVERTISE-REQUEST
        advertised_prefix = volatilestore.check_advertised_prefix(transaction_id, category='range', ptype=pattern.TYPE)

        # when address already has been advertised for this client use it
        if advertised_prefix:
            p = advertised_prefix
        else:
            # check if requesting client still has an active prefix that could be reused
            prefix = volatilestore.get_range_prefix_for_recycling(prefix=prefix_prefix,
                                                                 length=pattern.LENGTH,
                                                                 frange=frange,
                                                                 trange=trange,
                                                                 duid=Transactions[transaction_id].DUID,
                                                                 mac=Transactions[transaction_id].MAC)
            # the found prefix has to be in range - important after changed range boundaries
            if not prefix is None:
                if frange <= prefix[prefix_range_index:prefix_range_index+4].lower() <= trange:
                    p = ':'.join((prefix[0:4], prefix[4:8], prefix[8:12], prefix[12:16],
                                  prefix[16:20], prefix[20:24], prefix[24:28], prefix[28:32]))
                else:
                    # if prefixes are exceeded or something went wrong with from/to ranges return none
                    log.critical('Prefix address space %s[%s-%s] exceeded or something is wrong with from/to ranges' % (prefix_prefix, frange, trange))
                    return None
            else:
                # get highest active lease to increment address about 1
                prefix = volatilestore.get_highest_range_prefix(prefix=prefix_prefix,
                                                               length=pattern.LENGTH,
                                                               frange=frange,
                                                               trange=trange)
                # check if highest active lease still fits into range
                if not prefix is None:
                    if frange <= prefix[prefix_range_index:prefix_range_index+4].lower() < trange:
                        # if highest lease + 1 would not fit range limit is reached
                        if prefix[prefix_range_index:prefix_range_index+4].lower() >= trange:
                            # try to get one of the inactive old leases
                            prefix = volatilestore.get_oldest_inactive_range_prefix(prefix=prefix_prefix,
                                                                                    length=pattern.LENGTH,
                                                                                    frange=frange,
                                                                                    trange=trange)
                            if prefix is None:
                                # if none is available limit is reached and nothing returned
                                log.critical('Prefix address space %s[%s-%s] exceeded' % (prefix_prefix, frange,trange))
                                return None
                            else:
                                # if lease is OK use it
                                p = prefix
                        else:
                            # otherwise increase current maximum range limit by 1
                            p = p.replace('$range$', str(hex(int(prefix[prefix_range_index:prefix_range_index+4].lower(), 16) + 1)).split('x')[1])

                    else:
                        # if there is no lease yet or range limit is reached try to reactivate an old inactive lease
                        prefix = volatilestore.get_oldest_inactive_range_prefix(prefix=prefix_prefix,
                                                                                length=pattern.LENGTH,
                                                                                frange=frange,
                                                                                trange=trange)
                        if prefix is None:
                            # if there are no leases stored yet initiate lease storage
                            # this will be done only once - the first time if there is no other lease yet
                            # so it is safe to start from frange
                            if volatilestore.check_number_of_prefixes(prefix=prefix_prefix,
                                                                      length=pattern.LENGTH,
                                                                      frange=frange,
                                                                      trange=trange) <= 1:
                                p = p.replace('$range$', frange)
                            else:
                                # if none is available limit is reached and nothing returned
                                log.critical(
                                    'Prefix address space %s[%s-%s] exceeded' % (prefix_prefix, frange, trange))
                                return None
                        else:
                            # if there is a lease it might be used
                            p = prefix

                else:
                    # if there is no lease yet or range limit is reached try to reactivate an old inactive lease
                    prefix = volatilestore.get_oldest_inactive_range_prefix(prefix=prefix_prefix,
                                                                            length=pattern.LENGTH,
                                                                            frange=frange,
                                                                            trange=trange)
                    if prefix is None:
                        # if there are no leases stored yet initiate lease storage
                        # this will be done only once - the first time if there is no other lease yet
                        # so it is safe to start from frange
                        if volatilestore.check_number_of_prefixes(prefix=prefix_prefix,
                                                                  length=pattern.LENGTH,
                                                                  frange=frange,
                                                                  trange=trange) <= 1:
                            p = p.replace('$range$', frange)
                        else:
                            # if none is available limit is reached and nothing returned
                            log.critical('Prefix address space %s[%s-%s] exceeded' % (prefix_prefix, frange, trange))
                            return None
                    else:
                        # if there is a lease it might be used
                        p = prefix

    return decompress_ip6(p)


def get_ip_from_dns(hostname):
    """
        Get IPv6 address from DNS for address category 'dns'
    """
    try:
        answer = resolver_query.query(hostname, 'AAAA')
        return(decompress_ip6(answer.rrset.to_text().split(' ')[-1]))
    except dns.resolver.NoAIGNORE_MACnswer:
        return(False)
    except dns.resolver.NoNameservers:
        return(False)


def collect_macs(now):
    """
        collect MAC address from clients to link local addresses with MACs
        if a client has a new MAC the LLIP changes - with privacy extension enabled anyway
        calls local ip command to get neighbor cache - any more sophisticated idea is welcome!

        The Linux netlink method is considered stable now.
    """
    try:
        # Linux can use kernel neighbor cache
        if OS == 'Linux':
            for host in list(get_neighbor_cache_linux(cfg, IF_NUMBER, log, timer).values()):
                if not host.llip in CollectedMACs:
                    if host.llip.startswith('fe80'):
                        CollectedMACs[host.llip] = host
                        if cfg.LOG_MAC_LLIP == True:
                            log.info('Collected MAC %s for LinkLocalIP %s' % (host.mac, colonify_ip6(host.llip)))
                        if cfg.CACHE_MAC_LLIP == True:
                            volatilestore.store_mac_llip(host.mac, host.llip, timer)
        else:
            # subject to change - other distros might have other paths - might become a task
            # for a setup routine to find appropriate paths
            for host in subprocess.getoutput(NC[OS]['call']).splitlines():
                # get fragments of output line
                f = shlex.split(host)
                if f[NC[OS]['dev']] in cfg.INTERFACE and len(f) >= NC[OS]['len'] :
                    # get rid of %interface
                    f[NC[OS]['llip']] = decompress_ip6(f[NC[OS]['llip']].split('%')[0])
                    if f[NC[OS]['mac']] == '(incomplete)':
                        continue
                    # correct maybe shortened MAC
                    f[NC[OS]['mac']] = correct_mac(f[NC[OS]['mac']])
                    # put non yet existing LLIPs into dictionary - if they have MACs
                    if not f[NC[OS]['llip']] in CollectedMACs and f[NC[OS]['llip']].lower().startswith('fe80')\
                       and ':' in f[NC[OS]['mac']]:
                        CollectedMACs[f[NC[OS]['llip']]] = NeighborCacheRecord(llip=f[NC[OS]['llip']],
                                                                               mac=f[NC[OS]['mac']],
                                                                               interface=f[NC[OS]['dev']],
                                                                               now=now)
                        if cfg.LOG_MAC_LLIP == True:
                            log.info('Collected MAC %s for LinkLocalIP %s' % (f[NC[OS]['mac']], colonify_ip6(f[NC[OS]['llip']])))
                        volatilestore.store_mac_llip(f[NC[OS]['mac']], f[NC[OS]['llip']], timer)
    except Exception as err:
        traceback.print_exc(file=sys.stdout)
        sys.stdout.flush()
        log.error('collect_macs(): ' + str(err))


def dns_update(transaction_id, action='update'):
    """
        update DNS entries on specified nameserver
        at the moment this only works with Bind
        uses all addresses of client if they want to be dynamically updated

        regarding RFC 4704 5. there are 3 kinds of client behaviour for N O S:
        - client wants to update DNS itself -> sends 0 0 0
        - client wants server to update DNS -> sends 0 0 1
        - client wants no server DNS update -> sends 1 0 0
    """
    if Transactions[transaction_id].Client:
        # if allowed use client supplied hostname, otherwise that from config
        if cfg.DNS_USE_CLIENT_HOSTNAME:
            # hostname from transaction
            hostname = Transactions[transaction_id].Hostname
        else:
            # hostname from client info built from configuration
            hostname = Transactions[transaction_id].Client.Hostname

        # if address should be updated in DNS update it
        for a in Transactions[transaction_id].Client.Addresses:
            if a.DNS_UPDATE and hostname != '' and a.VALID == True:
                if cfg.DNS_IGNORE_CLIENT or Transactions[transaction_id].DNS_S == 1:
                    # put query into DNS query queue
                    dnsquery_queue.put((action, hostname, a))
        return True
    else:
        return False


def dns_delete(transaction_id, address='', action='release'):
    """
        delete DNS entries on specified nameserver
        at the moment this only works with ISC Bind
    """
    hostname, duid, mac, iaid = volatilestore.get_host_lease(address)

    # if address should be updated in DNS update it
    # local flag to check if address should be deleted from DNS
    delete = False

    for a in list(cfg.ADDRESSES.values()):
        # if there is any address type which prototype matches use its DNS ZONE
        if a.matches_prototype(address):
            # kind of RCF-compliant security measure - check if hostname and DUID from transaction fits them of store
            if duid == Transactions[transaction_id].DUID and\
               iaid == Transactions[transaction_id].IAID:
                delete = True
                # also check MAC address if MAC counts in general - not RFCish
                if 'mac' in cfg.IDENTIFICATION:
                    if not mac == Transactions[transaction_id].MAC:
                        delete = False

            if hostname != '' and delete == True:
                # use address from address types as template for the real
                # address to be deleted from DNS
                dns_address = copy.copy(a)
                dns_address.ADDRESS = colonify_ip6(address)
                # put query into DNS query queue
                dnsquery_queue.put((action, hostname, dns_address))
            # enough
            break


def modify_route(transaction_id, mode):
    """
        called when route has to be set - calls itself any external script or something like that
    """
    # check if client is already set - otherwise crashes
    if Transactions[transaction_id].Client != None:
        # only do anything if class of client has something defined to be called
        if (mode == 'up' and cfg.CLASSES[Transactions[transaction_id].Client.Class].CALL_UP != '') or \
           (mode == 'down' and cfg.CLASSES[Transactions[transaction_id].Client.Class].CALL_DOWN != ''):
            # collect possible prefixes, lengths and router ip addresses in list
            routes = list()
            for prefix in Transactions[transaction_id].Client.Prefixes:
                # use LinkLocal Address of client if wanted
                if prefix.ROUTE_LINK_LOCAL == True:
                    router = Transactions[transaction_id].ClientLLIP
                else:
                    if len(Transactions[transaction_id].Client.Addresses) == 1:
                        router = Transactions[transaction_id].Client.Addresses[0].ADDRESS
                    else:
                        router = None
                        log.error('modify_route: client needs exactly 1 address to be used as router to delegated prefix')
                if router != None:
                    routes.append(Route(prefix.PREFIX, prefix.LENGTH, router))

            if mode == 'up':
                call = cfg.CLASSES[Transactions[transaction_id].Client.Class].CALL_UP
            elif mode == 'down':
                call = cfg.CLASSES[Transactions[transaction_id].Client.Class].CALL_DOWN

            # call executables here
            for route in routes:
                route_queue.put((mode, call, route.prefix, route.length, route.router))


def manage_prefixes_routes():
    """
        delete or add inactive or active routes according to the prefixes in database
    """
    volatilestore.release_free_prefixes(timer)
    inactive_prefixes = volatilestore.get_inactive_prefixes()
    active_prefixes = volatilestore.get_active_prefixes()

    for prefix in inactive_prefixes:
        length, router, pclass = volatilestore.get_route(prefix)
        if pclass in cfg.CLASSES:
            route_queue.put(('down', cfg.CLASSES[pclass].CALL_DOWN, prefix, length, router))

    for prefix in active_prefixes:
        length, router, pclass = volatilestore.get_route(prefix)
        if pclass in cfg.CLASSES:
            route_queue.put(('up', cfg.CLASSES[pclass].CALL_UP, prefix, length, router))


class DNSQueryThread(threading.Thread):
    """
        thread for updating DNS entries of valid leases without blocking main thread
    """

    def __init__(self, dnsquery_queue):
        threading.Thread.__init__(self, name='DNSQuery')
        self.setDaemon(1)
        self.dnsquery_queue=dnsquery_queue

    def run(self):
        # wait for new queries in queue until the end of the world
        while True:
            action, hostname, a = self.dnsquery_queue.get()
            # colonify address for DNS
            address = colonify_ip6(a.ADDRESS)
            try:
                # update AAAA record, delete old entry first
                update = dns.update.Update(a.DNS_ZONE, keyring=Keyring)
                update.delete(hostname, 'AAAA')
                # if DNS should be updated do it - not the case if IP is released
                if action == 'update':
                    update.add(hostname, a.DNS_TTL, 'AAAA', address)
                dns.query.tcp(update, cfg.DNS_UPDATE_NAMESERVER)

                # the reverse record will be first checked if it points
                # to the current hostname, if not, it will be deleted first
                update_rev = dns.update.Update(a.DNS_REV_ZONE, keyring=Keyring)
                try:
                    answer = resolver_update.query(dns.reversename.from_address(address), 'PTR')
                    for rdata in answer:
                        hostname_ns = str(rdata).split('.')[0]
                        # if ip address is related to another host delete this one
                        if hostname_ns != hostname:
                            update_rev.delete(dns.reversename.from_address(address), 'PTR', hostname_ns + '.' + a.DNS_ZONE + '.')

                except dns.resolver.NXDOMAIN:
                    pass
                # if DNS should be updated do it - not the case if IP is released
                if action == 'update':
                    update_rev.add(dns.reversename.from_address(address), a.DNS_TTL, 'PTR', hostname + '.' + a.DNS_ZONE + '.')
                elif action == 'release':
                    update_rev.delete(dns.reversename.from_address(address), 'PTR')
                dns.query.tcp(update_rev, cfg.DNS_UPDATE_NAMESERVER)
            except Exception as err:
                traceback.print_exc(file=sys.stdout)
                sys.stdout.flush()
                log.error('DNSUPDATE: ' + str(err))


class TidyUpThread(threading.Thread):
    """
        clean leases and transactions if obsolete
    """
    def __init__(self):
        threading.Thread.__init__(self, name='TidyUp')
        self.setDaemon(1)

    def run(self):
        try:
            # counter for database cleaning interval
            dbcount = 0

            # get and delete invalid leases
            while True:
                # transaction data can be deleted after transaction is finished
                for t in list(Transactions.keys()):
                    try:
                        if timer > Transactions[t].Timestamp + cfg.CLEANING_INTERVAL * 10:
                            Transactions.pop(Transactions[t].ID)
                    except Exception as err:
                        log.error('TidyUp: TransactionID %s has already been deleted' % (str(err)))
                        traceback.print_exc(file=sys.stdout)
                        sys.stdout.flush()

                # if disconnected try reconnect
                if not volatilestore.connected:
                    volatilestore.DBConnect()
                else:
                    # cleaning database once per minute should be enough
                    if dbcount > 60/cfg.CLEANING_INTERVAL:
                        # remove leases which might not be recycled like random addresses for example
                        volatilestore.remove_leases(timer, 'random')
                        # set leases and prefixes free whose valid lifetime is over
                        volatilestore.release_free_leases(timer)
                        volatilestore.release_free_prefixes(timer)
                        # unlock advertised leases and prefixes remaining
                        volatilestore.unlock_unused_advertised_leases(timer)
                        volatilestore.unlock_unused_advertised_prefixes(timer)
                        # remove routes with inactive prefixes
                        self.check_routes()
                        # check for brute force clients and put them into blacklist if necessary
                        self.check_requests(timer)
                        dbcount = 0
                dbcount += 1

                # clean collected MAC addresses after 300 seconds
                # some Linuxes seem to be pretty slow and run out of the previous 30 seconds
                if cfg.CACHE_MAC_LLIP == False:
                    timestamp = timer
                    for record in list(CollectedMACs.values()):
                        if record.timestamp + 60 * cfg.CLEANING_INTERVAL < timestamp:
                            if cfg.LOG_MAC_LLIP == True:
                                log.info('Deleted MAC %s for LinkLocalIP %s' % (record.mac, colonify_ip6(record.llip)))
                            CollectedMACs.pop(record.llip)
                    del timestamp
                time.sleep(cfg.CLEANING_INTERVAL)
        except:
            traceback.print_exc(file=sys.stdout)
            sys.stdout.flush()


    def check_routes(self):
        """
            remove routes with inactive prefixes
        """
        for prefix in volatilestore.get_inactive_prefixes():
            length, router, pclass = volatilestore.get_route(prefix)
            # hopefully the class stored in database still exists
            if pclass in cfg.CLASSES:
                route_queue.put(('down', cfg.CLASSES[pclass].CALL_DOWN, prefix, length, router))


    def check_requests(self, now):
        """
            check for brute force clients and put them into blacklist if necessary
            get time as now from caller
        """

        # clean blacklist
        for client in list(requests_blacklist.keys()):
            if now > requests_blacklist[client].timestamp + cfg.REQUEST_LIMIT_RELEASE_TIME:
                log.info("Releasing client {0} from blacklist".format(client))
                requests_blacklist.pop(client)

        # clean default requests list
        for client in list(requests.keys()):
            if now > requests[client].timestamp + cfg.REQUEST_LIMIT_TIME:
                if requests[client].count > cfg.REQUEST_LIMIT_COUNT:
                    log.info("Blacklisting client {0} after {1} requests".format(client, requests[client].count))
                    requests_blacklist[client] = requests.pop(client)
                else:
                    requests.pop(client)


class RouteThread(threading.Thread):
    """
        thread for updating routes without blocking main thread
    """

    def __init__(self, route_queue):
        threading.Thread.__init__(self, name='Route')
        self.setDaemon(1)
        self.route_queue=route_queue


    def run(self):
        """
            wait for new queries in queue until the end of the world
        """
        while True:
            mode, call, prefix, length, router = self.route_queue.get()
            call_real = call.replace('$prefix$', colonify_ip6(prefix)).\
                             replace('$length$', str(length)).\
                             replace('$router$', colonify_ip6(router))
            # subprocess needs list as argument which it gets by split()
            try:
                result = subprocess.call(call_real.split(' '))
            except Exception as err:
                result = err
            # ignore result to avoid routes being set but not noted in database when a command like
            # 'ip -6 route delete' gives a return code not 0 because a route already exists
            if mode == 'up':
                volatilestore.store_route(prefix, length, router, timer)
            if mode == 'down':
                volatilestore.remove_route(prefix)
            log.info("Called '{0}' to modify route - result: {1}".format(call_real, result))


class TimerThread(threading.Thread):
    """
        thread for timer, used in different places
    """

    def __init__(self):
        threading.Thread.__init__(self, name='Timer')
        self.setDaemon(1)

    def run(self):
        global timer
        while True:
            timer = int(time.time())
            time.sleep(1)


class Client(object):
    """
        client object, generated from configuration database or on the fly
    """
    def __init__(self):
        # Addresses, depending on class or fixed addresses
        self.Addresses = list()
        # Bootfiles, depending on class and architecture
        self.Bootfiles = list()
        # Last chosen Bootfile
        self.ChosenBootfile = ''
        # Prefixes, depending on class or fixed prefixes
        self.Prefixes = list()
        # DUID
        self.DUID = ''
        # Hostname
        self.Hostname = ''
        # Class/role of client
        self.Class = ''
        # MAC
        self.MAC = ''
        # timestamp of last update
        self.LastUpdate = ''


    def _get_options_string(self):
        """
            all attributes in a string for logging
        """
        optionsstring = ''
        # put own attributes into a string
        options = sorted(list(self.__dict__.keys()))
        # options.sort()
        for o in options:
            # ignore some attributes
            if not o in IGNORED_LOG_OPTIONS and \
               not self.__dict__[o] in EMPTY_OPTIONS:
                if o == 'Addresses':
                    if 'addresses' in cfg.CLASSES[self.Class].ADVERTISE:
                        option = 'Addresses:'
                        for a in self.__dict__[o]:
                            option += ' ' + colonify_ip6(a.ADDRESS)
                        optionsstring = optionsstring + ' | '  + option
                elif o == 'Bootfiles':
                    option = 'Bootfiles:'
                    for a in self.__dict__[o]:
                        option += ' ' + a.BOOTFILE_URL
                    optionsstring = optionsstring + ' | '  + option
                elif o == 'Prefixes':
                    if 'prefixes' in cfg.CLASSES[self.Class].ADVERTISE:
                        option = 'Prefixes:'
                        for p in self.__dict__[o]:
                            option += ' {0}/{1}'.format(colonify_ip6(p.PREFIX), p.LENGTH)
                        optionsstring = optionsstring + ' | '  + option
                else:
                    option = o + ': ' + str(self.__dict__[o])
                    optionsstring = optionsstring + ' | '  + option
        return optionsstring


class Route(object):
    """
        store data of a route which should be given to an external application
        router is here the prefix requesting host
    """
    def __init__(self, prefix, length, router):
        self.prefix = prefix
        self.length = length
        self.router = router


class Request(object):
    """
        to be stored in requests dictionary to log client requests to be able to find brute force clients
    """
    def __init__(self, client):
        self.client = client
        self.count = 1
        self.timestamp = timer


class Transaction(object):
    """
        all data of one transaction, to be collected in Transactions
    """
    def __init__(self, transaction_id, client_llip, interface, message_type, options):
        # Transaction ID
        self.ID = transaction_id
        # Link Local IP of client
        self.ClientLLIP = client_llip
        # Interface the request came in
        self.Interface = interface
        # MAC address
        self.MAC = DUMMY_MAC
        # last message for following the protocol
        self.LastMessageReceivedType = message_type
        # dictionary for options
        self.OptionsRaw = options
        # default dummy OptionsRequest
        self.OptionsRequest = list()
        # timestamp to manage/clean transactions
        self.Timestamp = timer
        # dummy hostname
        self.FQDN = ''
        self.Hostname = ''
        # DNS Options for option 39
        self.DNS_N = 0
        self.DNS_O = 0
        self.DNS_S = 0
        # dummy IAID
        self.IAID = DUMMY_IAID
        # dummy IAT1
        self.IAT1 = cfg.T1
        # dummy IAT2
        self.IAT2 = cfg.T2
        # IA option - NA, TA or PD -> DHCPv6 option 3, 4 or 25
        # to be used in option_requests in Handler.build_response()
        self.IA_Options = list()
        # Addresses given by client, for example for RENEW or RELEASE requests
        self.Addresses = list()
        # same with prefixes
        self.Prefixes = list()
        # might be used against clients that are running wild
        # initial 1 as being increased after handling
        self.Counter = 1
        # temporary storage for client configuration from DB config
        # - only used if config comes from DB
        self.ClientConfigDB = None
        # client config from config store
        self.Client = None
        # Vendor Class Option
        self.VendorClassEN = None
        self.VendorClassData = ''
        # Rapid Commit flag
        self.RapidCommit = False
        # answer type - take from class definition, one of 'normal', 'noaddress', 'noprefix' or 'none'
        # defaults to 'normal' as this is the main purpose of dhcpy6d
        self.Answer = 'normal'
        # default DUID values
        self.DUID = ''
        self.DUIDType = 1
        self.DUID_EN = 0
        # Elapsed Time - option 8, at least sent by WIDE dhcp6c when requesting delegated prefix
        self.ElapsedTime = 0
        # Client architecture type (RFC 5970)
        self.ClientArchitecture = ''
        # Known client architecture type (RFC 4578) (e.g. EFI x86 - 64)
        self.KnownClientArchitecture = ''
        # UserClass (https://tools.ietf.org/html/rfc3315#section-22.15)
        self.UserClass = ''

        # DUID of client
        # 1 Client Identifier Option
        if 1 in options:
            self.DUID = options[1]
            self.DUIDType = int(options[1][0:4], 16)
            # DUID-EN can be retrieved from DUID
            if self.DUIDType == 2:
                # some HP printers seem to produce pretty bad requests, thus some cleaning is necessary
                # e.g. '1 1 1 00020000000b0026b1f72a49' instead of '00020000000b0026b1f72a49'
                self.DUID_EN = int(options[1].split(' ')[-1][4:12], 16)

        # Identity Association for Non-temporary Addresses
        # 3 Identity Association for Non-temporary Address Option
        if 3 in options:
            for payload in options[3]:
                self.IAID = payload[0:8]
                self.IAT1 = int(payload[8:16], 16)
                self.IAT2 = int(payload[16:24], 16)

                # addresses given by client if any
                for a in range(len(payload[32:])/44):
                    address = payload[32:][(a*56):(a*56)+32]
                    # in case an address is asked for twice by one host ignore the twin
                    if not address in self.Addresses:
                        self.Addresses.append(address)
            self.IA_Options.append(3)

        # Identity Association for Temporary Addresses
        # 4 Identity Association for Temporary Address Option
        if 4 in options:
            for payload in options[4]:
                self.IAID = payload[0:8]
                self.IAT1 = int(payload[8:16], 16)
                self.IAT2 = int(payload[16:24], 16)

                # addresses given by client if any
                for a in range(len(payload[32:])/44):
                    address = payload[32:][(a*56):(a*56)+32]
                    # in case an address is asked for twice by one host ignore the twin
                    if not address in self.Addresses:
                        self.Addresses.append(address)
            self.IA_Options.append(4)

        # Options Requested
        # 6 Option Request Option
        if 6 in options:
            options_request = list()
            opts = options[6][:]
            while len(opts) > 0:
                options_request.append(int(opts[0:4], 16))
                opts = opts[4:]
            self.OptionsRequest = options_request

        # 8 Elapsed Time
        # RFC 3315: This time is expressed in hundredths of a second (10^-2 seconds).
        if 8 in options:
            self.ElapsedTime = int(options[8][0:8], 16)

        # 14 Rapid Commit flag
        if 14 in options:
            self.RapidCommit = True

        # 15 User Class Option
        if 15 in options:
            user_class_raw = options[15]
            # raw user class is prefixed with null byte (00 in hex) and eot (04 in hex)
            self.UserClass = binascii.a2b_hex(user_class_raw[4:])

        # 16 Vendor Class Option
        if 16 in options:
            self.VendorClassEN = int(options[16][0:8], 16)
            self.VendorClassData = binascii.unhexlify(options[16][12:])

        # Identity Association for Prefix Delegation
        # 25 Identity Association for Prefix Delegation
        if 25 in options:
            for payload in options[25]:
                self.IAID = payload[0:8]
                self.IAT1 = int(payload[8:16], 16)
                self.IAT2 = int(payload[16:24], 16)

                # iaid        t1        t2       ia_prefix   opt_length       preferred validlt    length    prefix
                #00000001    ffffffff  ffffffff  001a        0019             00000e10   00001518    30     fd661234000000000000000000000000
                #8               16      24      28          32                  40      48          50      82

                # Prefixes given by client if any
                for p in range(len(payload[32:])/50):
                    prefix = payload[50:][(p*58):(p*58)+32]
                    length = int(payload[48:][(p*58):(p*58)+2], 16)
                    prefix_combined = combine_prefix_length(prefix, length)
                    # in case a prefix is asked for twice by one host ignore the twin
                    if not prefix_combined in self.Prefixes:
                        self.Prefixes.append(prefix_combined)
                    del(prefix, length, prefix_combined)
            self.IA_Options.append(25)

        # FQDN
        # 39 FQDN Option
        if 39 in options:
            bits = ('%4s' % (str(bin(int(options[39][1:2]))).strip('0b'))).replace(' ', '0')
            self.DNS_N = int(bits[1])
            self.DNS_O = int(bits[2])
            self.DNS_S = int(bits[3])
            # only hostname needed
            self.FQDN = convert_binary_to_dns(options[39][2:])
            self.Hostname = self.FQDN.split('.')[0].lower()
            # test if hostname is valid
            n = re.compile('^([a-z0-9\-\_]+)*$')
            if n.match(self.Hostname) == None:
                self.Hostname = ''
            del n

        # Client architecture type
        # 61 Client System Architecture Type Option
        if 61 in options:
            # raw client architecture is supplied as a 16-bit integer (e. g. 0007)
            # See https://tools.ietf.org/html/rfc4578#section-2.1
            client_architecture_raw = options[61]
            # short number (0007 => 7 for dictionary usage)
            client_architecture_short = int(client_architecture_raw)

            self.ClientArchitecture = client_architecture_raw

            if client_architecture_short in ARCHITECTURE_TYPE:
                self.KnownClientArchitecture = ARCHITECTURE_TYPE[client_architecture_short]

    def _get_options_string(self):
        """
            get all options in one string for debugging
        """
        optionsstring = ''
        # put own attributes into a string
        options = sorted(list(self.__dict__.keys()))
        # options.sort()
        for o in options:
            # ignore some attributes
            if not o in IGNORED_LOG_OPTIONS and \
               not self.__dict__[o] in EMPTY_OPTIONS:
                if o == 'Addresses':
                    if (3 or 4) in self.IA_Options:
                        option = 'Addresses:'
                        for a in self.__dict__[o]:
                            option += ' ' + colonify_ip6(a)
                        optionsstring = optionsstring + ' | '  + option
                elif o == 'Prefixes':
                    if 25 in self.IA_Options:
                        option = 'Prefixes:'
                        for p in self.__dict__[o]:
                            prefix, length = split_prefix(p)
                            option += combine_prefix_length(colonify_ip6(prefix), length)
                elif o == 'ClientLLIP':
                    option = 'ClientLLIP: ' + colonify_ip6(self.__dict__['ClientLLIP'])
                    optionsstring = optionsstring + ' | '  + option
                else:
                    option = o + ': ' + str(self.__dict__[o])
                    optionsstring = optionsstring + ' | '  + option

        return optionsstring


class UDPMulticastIPv6(socketserver.UnixDatagramServer):
    """
        modify server_bind to work with multicast
        add DHCPv6 multicast group ff02::1:2
    """
    def server_bind(self):
        """
            multicast & python: http://code.activestate.com/recipes/442490/
        """
        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        # multicast parameters
        # hop is one because it is all about the same subnet
        self.socket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_LOOP, 0)
        self.socket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_HOPS, 1)

        for i in cfg.INTERFACE:
            # IF_NAME[i] = LIBC.if_nametoindex(i)
            IF_NAME[i] = socket.if_nametoindex(i)
            IF_NUMBER[IF_NAME[i]] = i
            if_number = struct.pack('I', IF_NAME[i])
            mgroup = socket.inet_pton(socket.AF_INET6, cfg.MCAST) + if_number

            # join multicast group - should work definitively if not ignoring interface at startup
            if cfg.IGNORE_INTERFACE:
                try:
                    self.socket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_JOIN_GROUP, mgroup)
                except Exception as err:
                    print(err)
            else:
                self.socket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_JOIN_GROUP, mgroup)

        # bind socket to server address
        self.socket.bind(self.server_address)

        # attempt to avoid blocking
        self.socket.setblocking(False)

        # some more requests?
        self.request_queue_size = 100


class Handler(socketserver.DatagramRequestHandler):
    """
        manage all incoming datagrams
    """

    def handle(self):
        """
            request handling happens here
        """
        # empty dummy response
        self.response = ''

        # raw address+interface, used for requests monitoring
        client_address = copy.deepcopy(self.client_address[0])
        try:
            interface = socket.if_indextoname(self.client_address[3])
        except OSError:
            # strangely the interface index is 0 if sent to localhost -
            # even if 'lo' has the index 1
            interface = ''

        # avoid processing requests of unknown clients which cannot be found in the neighbor cache table
        # only makes sense if classes are not ignored and thus the neighbor cache is used
        if not cfg.IGNORE_MAC and cfg.IGNORE_UNKNOWN_CLIENTS:
            if client_address in requests_blacklist:
                return False

        # default is no control request
        self.is_control_message = False

        # check if we are limiting requests
        if cfg.REQUEST_LIMIT:
            if cfg.REQUEST_LIMIT_IDENTIFICATION == 'llip':
                # avoid further processing if client is known to be bad
                if client_address in requests_blacklist:
                    return False
                # add client to requests tracker if not known, otherwise raise counter
                if client_address not in requests:
                    requests[client_address] = Request(client_address)
                else:
                    requests[client_address].count += 1
            # otherwise a MAC address
            else:
                # llip = decompress_ip6(client_address.split('%')[0])
                llip = decompress_ip6(client_address)
                if llip in CollectedMACs:
                    mac = copy.deepcopy(CollectedMACs[llip].mac)
                    if mac in requests_blacklist:
                        return False
                    # add client to requests tracker if not known, otherwise raise counter
                    if mac not in requests:
                        requests[mac] = Request(mac)
                    else:
                        requests[mac].count += 1
                del llip
        try:
            # convert raw message into ascii-bytes
            raw_bytes = binascii.hexlify(self.request[0])

            # local connection is a control message
            # for BSD there might be different localhost addresses
            if client_address == LOCALHOST and interface in LOCALHOST_INTERFACES:
                self.is_control_message = True

            # do nothing if interface is not configured
            if not interface in cfg.INTERFACE and not self.is_control_message:
                return False

            # bad or too short message is thrown away
            if not len(raw_bytes) > 8:
                pass
            elif self.is_control_message:
                self.control_message(raw_bytes)
            else:
                message_type = int(raw_bytes[0:2], 16)
                transaction_id = raw_bytes[2:8]
                raw_bytes_options = raw_bytes[8:]
                options = {}
                while len(raw_bytes_options) > 0:
                    # option type and length are 2 bytes each
                    option = int(raw_bytes_options[0:4], 16)
                    length = int(raw_bytes_options[4:8], 16)
                    # *2 because 2 bytes make 1 char
                    value = raw_bytes_options[8:8 + length*2]
                    # Microsoft behaves a little bit different than the other
                    # clients - in RENEW and REBIND request multiple addresses of an
                    # IAID are not requested all in one option type 3 but
                    # come in several options of type 3 what leads to some confusion
                    if not option in IA_OPTIONS:
                        options[option] = value
                    else:
                        if option in options:
                            # if options list already exists append value
                            options[option].append(value)
                        else:
                            # otherwise create list and put value in
                            options[option] = [value]

                    # cut off bytes worked on
                    raw_bytes_options = raw_bytes_options[8 + length*2:]

                # only valid messages will be processed
                if message_type in MESSAGE_TYPES:
                    # 2. create Transaction object if not yet done
                    if not transaction_id in Transactions:
                        client_llip = decompress_ip6(client_address)
                        Transactions[transaction_id] = Transaction(transaction_id, client_llip, interface, message_type, options)
                        # add client MAC address to transaction object
                        if Transactions[transaction_id].ClientLLIP in CollectedMACs:
                            if not cfg.IGNORE_MAC:
                                Transactions[transaction_id].MAC = CollectedMACs[Transactions[transaction_id].ClientLLIP].mac
                    else:
                        Transactions[transaction_id].Timestamp = timer
                        Transactions[transaction_id].LastMessageReceivedType = message_type

                    # log incoming messages
                    log.info('%s | TransactionID: %s%s' % (MESSAGE_TYPES[message_type], transaction_id, Transactions[transaction_id]._get_options_string()))

                    # 3. answer requests
                    # check if client sent a valid DUID (alphanumeric)
                    if Transactions[transaction_id].DUID.isalnum():
                        # if request was not addressed to multicast do nothing but logging
                        if Transactions[transaction_id].Interface == '':
                            log.info('TransactionID: %s | %s' % (transaction_id, 'Multicast necessary but message came from %s' % (colonify_ip6(Transactions[transaction_id].ClientLLIP))))
                            # reset transaction counter
                            Transactions[transaction_id].Counter = 0
                        else:
                            # client will get answer if its LLIP & MAC is known
                            if not Transactions[transaction_id].ClientLLIP in CollectedMACs:
                                if not cfg.IGNORE_MAC:
                                    # complete MAC collection - will make most sence on Linux and its native neighborcache access
                                    collect_macs(timer)

                                    # when still no trace of the client in neighbor cache then send silly signal back
                                    if not Transactions[transaction_id].ClientLLIP in CollectedMACs:
                                        # if not known send status code option failure to get
                                        # LLIP/MAC mapping from neighbor cache
                                        # status code 'Success' sounds silly but works best
                                        self.build_response(7, transaction_id, [13], status=0)
                                        # complete MAC collection
                                        collect_macs(timer)
                                        # if client cannot be found in collected MACs
                                        if not Transactions[transaction_id].ClientLLIP in CollectedMACs:
                                            if cfg.IGNORE_UNKNOWN_CLIENTS and client_address in requests:
                                                if requests[client_address].count > 1:
                                                    requests_blacklist[client_address] = Request(client_address)
                                                    log.info("Blacklisting unknown client {0}".format(client_address))
                                                    return False

                                    # try to add client MAC address to transaction object
                                    try:
                                        Transactions[transaction_id].MAC = CollectedMACs[Transactions[transaction_id].ClientLLIP].mac
                                    except:
                                        # MAC not yet found :-(
                                        if cfg.LOG_MAC_LLIP == True:
                                            log.info('TransactionID: %s | %s' % (transaction_id, 'MAC address for LinkLocalIP %s unknown' % (colonify_ip6(Transactions[transaction_id].ClientLLIP))))

                            # if finally there is some info about the client or MACs play no role try to answer the request
                            if Transactions[transaction_id].ClientLLIP in CollectedMACs or cfg.IGNORE_MAC:
                                if not cfg.IGNORE_MAC:
                                    if Transactions[transaction_id].MAC == DUMMY_MAC:
                                        Transactions[transaction_id].MAC = CollectedMACs[Transactions[transaction_id].ClientLLIP].mac

                                # ADVERTISE
                                # if last request was a SOLICIT send an ADVERTISE (type 2) back
                                if Transactions[transaction_id].LastMessageReceivedType == 1 \
                                   and Transactions[transaction_id].RapidCommit == False:
                                    # preference option (7) is for free
                                    self.build_response(2, transaction_id, Transactions[transaction_id].IA_Options + \
                                                        [7] + Transactions[transaction_id].OptionsRequest)

                                    # store leases for addresses and lock advertised address
                                    #volatilestore.store(transaction_id, timer)
                                    volatilestore.store(copy.deepcopy(Transactions[transaction_id]), timer)

                                # REQUEST
                                # if last request was a REQUEST (type 3) send a REPLY (type 7) back
                                elif Transactions[transaction_id].LastMessageReceivedType == 3 or \
                                     (Transactions[transaction_id].LastMessageReceivedType == 1 and \
                                      Transactions[transaction_id].RapidCommit == True):
                                    # preference option (7) is for free
                                    # if RapidCommit was set give it back
                                    if not Transactions[transaction_id].RapidCommit:
                                        self.build_response(7, transaction_id, Transactions[transaction_id].IA_Options + \
                                                            [7] + Transactions[transaction_id].OptionsRequest)
                                    else:
                                        self.build_response(7, transaction_id, Transactions[transaction_id].IA_Options + \
                                                            [7] + [14] + Transactions[transaction_id].OptionsRequest)
                                    # store leases for addresses
                                    #volatilestore.store(transaction_id, timer)
                                    volatilestore.store(copy.deepcopy(Transactions[transaction_id]), timer)

                                    # run external script for setting a route to the delegated prefix
                                    if 25 in Transactions[transaction_id].IA_Options:
                                        modify_route(transaction_id, 'up')

                                    if cfg.DNS_UPDATE:
                                        dns_update(transaction_id)

                                # CONFIRM
                                # if last request was a CONFIRM (4) send a REPLY (type 7) back
                                # Due to problems with different clients they will get a not-available-reply
                                # but the next ADVERTISE will offer them the last known and still active
                                # lease. This makes sense in case of fixed MAC-based, addresses, ranges and
                                # ID-based addresses, Random addresses will be recalculated
                                elif Transactions[transaction_id].LastMessageReceivedType == 4:
                                    # the RFC 3315 is a little bit confusing regarding CONFIRM
                                    # messages so it won't hurt to simply let the client
                                    # solicit addresses again via answering 'NotOnLink'
                                    # thus client is forced in every case to solicit a new address which
                                    # might as well be the old one or a new if prefix has changed
                                    self.build_response(7, transaction_id, [13], status=4)

                                # RENEW
                                # if last request was a RENEW (type 5) send a REPLY (type 7) back
                                elif Transactions[transaction_id].LastMessageReceivedType == 5:
                                    self.build_response(7, transaction_id, Transactions[transaction_id].IA_Options + [7] + \
                                                        Transactions[transaction_id].OptionsRequest)
                                    # store leases for addresses
                                    #volatilestore.store(transaction_id, timer)
                                    volatilestore.store(copy.deepcopy(Transactions[transaction_id]), timer)
                                    if cfg.DNS_UPDATE:
                                        dns_update(transaction_id)

                                # REBIND
                                # if last request was a REBIND (type 6) send a REPLY (type 7) back
                                elif Transactions[transaction_id].LastMessageReceivedType == 6:
                                    self.build_response(7, transaction_id, Transactions[transaction_id].IA_Options + [7] + \
                                                        Transactions[transaction_id].OptionsRequest)
                                    # store leases for addresses
                                    #volatilestore.store(transaction_id, timer)
                                    volatilestore.store(copy.deepcopy(Transactions[transaction_id]), timer)

                                # RELEASE
                                # if last request was a RELEASE (type 8) send a REPLY (type 7) back
                                elif Transactions[transaction_id].LastMessageReceivedType == 8:
                                    #  build client to be able to delete it from DNS
                                    if Transactions[transaction_id].Client == None:
                                        Transactions[transaction_id].Client = build_client(transaction_id)
                                    if cfg.DNS_UPDATE:
                                        for a in Transactions[transaction_id].Addresses:
                                            dns_delete(transaction_id, address=a, action='release')
                                    for a in Transactions[transaction_id].Addresses:
                                        # free lease
                                        volatilestore.release_lease(a, timer)
                                    for p in Transactions[transaction_id].Prefixes:
                                        # free prefix - without length
                                        volatilestore.release_prefix(p.split('/')[0], timer)
                                        # delete route to formerly requesting client
                                        modify_route(transaction_id, 'down')
                                    # send status code option (type 13) with success (type 0)
                                    self.build_response(7, transaction_id, [13], status=0)

                                # DECLINE
                                # if last request was a DECLINE (type 9) send a REPLY (type 7) back
                                elif Transactions[transaction_id].LastMessageReceivedType == 9:
                                    # maybe has to be refined - now only a status code 'NoBinding' is answered
                                    self.build_response(7, transaction_id, [13], status=3)

                                # INFORMATION-REQUEST
                                # if last request was an INFORMATION-REQUEST (type 11) send a REPLY (type 7) back
                                elif Transactions[transaction_id].LastMessageReceivedType == 11:
                                    self.build_response(7, transaction_id, Transactions[transaction_id].OptionsRequest)

                                # general error - statuscode 1 'Failure'
                                else:
                                    # send Status Code Option (type 13) with status code 'UnspecFail'
                                    self.build_response(7, transaction_id, [13], status=1)

                    # count requests of transaction
                    # if there will be too much something went wrong
                    # may be evaluated to reset the whole transaction
                    Transactions[transaction_id].Counter += 1

        except Exception as err:
            traceback.print_exc(file=sys.stdout)
            sys.stdout.flush()
            log.error('handle(): %s | Caused by: %s | Transaction: %s' % (str(err), client_address, transaction_id))
            return None


    def build_response(self, response_type, transaction_id, options_request, status=0):
        """
            creates answer and puts it into self.response
            arguments:
                response_type - mostly 2 or 7
                transaction_id
                option_request
                status - mostly 0 (OK)
            response will be sent by self.finish()
        """
        try:
            # Header
            # response type + transaction id
            response_ascii = '%02x' % (response_type)
            response_ascii += transaction_id

            # these options are always useful
            # Option 1 client identifier
            response_ascii += build_option(1, Transactions[transaction_id].DUID)
            # Option 2 server identifier
            response_ascii += build_option(2, cfg.SERVERDUID)

            # list of options in answer to be logged
            options_answer = []

            # IA_NA non-temporary addresses
            # Option 3 + 5 Identity Association for Non-temporary Address
            if 3 in options_request:
                # check if MAC of LLIP is really known
                if Transactions[transaction_id].ClientLLIP in CollectedMACs or cfg.IGNORE_MAC:
                    # collect client information
                    if Transactions[transaction_id].Client == None:
                        Transactions[transaction_id].Client = build_client(transaction_id)

                    if 'addresses' in cfg.CLASSES[Transactions[transaction_id].Client.Class].ADVERTISE and \
                                    (3 or 4) in Transactions[transaction_id].IA_Options:
                        # check if only a short NoAddrAvail answer or none at all is to be returned
                        if not Transactions[transaction_id].Answer == 'normal':
                            if Transactions[transaction_id].Answer == 'noaddress':
                                # Option 13 Status Code Option - statuscode is 2: 'No Addresses available'
                                response_ascii += build_option(13, '%04x' % (2))
                                # clean client addresses which not be deployed anyway
                                Transactions[transaction_id].Client.Addresses[:] = []
                                # options in answer to be logged
                                options_answer.append(13)
                            else:
                                # clean response as there is nothing to respond in case of answer = none
                                self.response = ''
                                return None
                        else:
                            # if client could not be built because of database problems send
                            # status message back
                            if Transactions[transaction_id].Client:
                                # embed option 5 into option 3 - several if necessary
                                ia_addresses = ''
                                try:
                                    for address in Transactions[transaction_id].Client.Addresses:
                                        if address.IA_TYPE == 'na':
                                            ipv6_address = binascii.b2a_hex(socket.inet_pton(socket.AF_INET6,
                                                                                             colonify_ip6(address.ADDRESS)))
                                            # if a transaction consists of too many requests from client -
                                            # - might be caused by going wild Windows clients -
                                            # reset all addresses with lifetime 0
                                            # lets start with maximal transaction count of 10
                                            if Transactions[transaction_id].Counter < 10:
                                                preferred_lifetime = '%08x' % (int(address.PREFERRED_LIFETIME))
                                                valid_lifetime = '%08x' % (int(address.VALID_LIFETIME))
                                            else:
                                                preferred_lifetime = '%08x' % (0)
                                                valid_lifetime = '%08x' % (0)
                                            ia_addresses += build_option(5, ipv6_address + preferred_lifetime + valid_lifetime)

                                    if not ia_addresses == '':
                                        #
                                        # todo: default clients sometimes seem to have class ''
                                        #
                                        if Transactions[transaction_id].Client.Class != '':
                                            t1 = '%08x' % (int(cfg.CLASSES[Transactions[transaction_id].Client.Class].T1))
                                            t2 = '%08x' % (int(cfg.CLASSES[Transactions[transaction_id].Client.Class].T2))
                                        else:
                                            t1 = '%08x' % (int(cfg.T1))
                                            t2 = '%08x' % (int(cfg.T2))

                                        response_ascii += build_option(3, Transactions[transaction_id].IAID + t1 + t2 + ia_addresses)
                                    # options in answer to be logged
                                    options_answer.append(3)
                                except:
                                    # Option 13 Status Code Option - statuscode is 2: 'No Addresses available'
                                    response_ascii += build_option(13, '%04x' % (2))
                                    # options in answer to be logged
                                    options_answer.append(13)
                            else:
                                # Option 13 Status Code Option - statuscode is 2: 'No Addresses available'
                                response_ascii += build_option(13, '%04x' % (2))
                                # options in answer to be logged
                                options_answer.append(13)

            # IA_TA temporary addresses
            if 4 in options_request:
                # check if MAC of LLIP is really known
                if Transactions[transaction_id].ClientLLIP in CollectedMACs or cfg.IGNORE_MAC:
                    # collect client information
                    if Transactions[transaction_id].Client == None:
                        Transactions[transaction_id].Client = build_client(transaction_id)

                    if 'addresses' in cfg.CLASSES[Transactions[transaction_id].Client.Class].ADVERTISE and \
                        (3 or 4) in Transactions[transaction_id].IA_Options:
                        # check if only a short NoAddrAvail answer or none at all ist t be returned
                        if not Transactions[transaction_id].Answer == 'normal':
                            if Transactions[transaction_id].Answer == 'noaddress':
                                # Option 13 Status Code Option - statuscode is 2: 'No Addresses available'
                                response_ascii += build_option(13, '%04x' % (2))
                                # clean client addresses which not be deployed anyway
                                Transactions[transaction_id].Client.Addresses[:] = []
                                # options in answer to be logged
                                options_answer.append(13)
                            else:
                                # clean response as there is nothing to respond in case of answer = none
                                self.response = ''
                                return None
                        else:
                            # if client could not be built because of database problems send
                            # status message back
                            if Transactions[transaction_id].Client:
                                # embed option 5 into option 4 - several if necessary
                                ia_addresses = ''
                                try:
                                    for address in Transactions[transaction_id].Client.Addresses:
                                        if address.IA_TYPE == 'ta':
                                            ipv6_address = binascii.b2a_hex(socket.inet_pton(socket.AF_INET6,
                                                                                             colonify_ip6(address.ADDRESS)))
                                            # if a transaction consists of too many requests from client -
                                            # - might be caused by going wild Windows clients -
                                            # reset all addresses with lifetime 0
                                            # lets start with maximal transaction count of 10
                                            if Transactions[transaction_id].Counter < 10:
                                                preferred_lifetime = '%08x' % (int(address.PREFERRED_LIFETIME))
                                                valid_lifetime = '%08x' % (int(address.VALID_LIFETIME))
                                            else:
                                                preferred_lifetime = '%08x' % (0)
                                                valid_lifetime = '%08x' % (0)
                                            ia_addresses += build_option(5, ipv6_address + preferred_lifetime + valid_lifetime)
                                    if not ia_addresses == '':
                                        response_ascii += build_option(4, Transactions[transaction_id].IAID + ia_addresses)
                                    # options in answer to be logged
                                    options_answer.append(4)
                                except:
                                    # Option 13 Status Code Option - statuscode is 2: 'No Addresses available'
                                    response_ascii += build_option(13, '%04x' % (2))
                                    # options in answer to be logged
                                    options_answer.append(13)
                            else:
                                # Option 13 Status Code Option - statuscode is 2: 'No Addresses available'
                                response_ascii += build_option(13, '%04x' % (2))
                                # options in answer to be logged
                                options_answer.append(13)

            # Option 7 Server Preference
            if 7 in options_request:
                response_ascii += build_option(7, '%02x' % (int(cfg.SERVER_PREFERENCE)))
                # options in answer to be logged
                options_answer.append(7)

            # Option 11 Authentication Option
            # seems to be pretty unused at the moment - to be done
            if 11 in options_request:
                # '3' for Reconfigure Key Authentication Protocol
                protocol = '%02x' % (3)
                # '1' for algorithm
                algorithm = '%02x' % (1)
                # assuming '0' as valid Replay Detection method
                rdm = '%02x' % (0)
                # Replay Detection - current time for example
                replay_detection = '%016x' % (int(time.time()))
                # Authentication Information Type
                # first 1, later with HMAC-MD5  2
                ai_type = '%02x' % (1)
                authentication_information = cfg.AUTHENTICATION_INFORMATION
                # stuffed together
                response_ascii += build_option(11, protocol + algorithm + rdm + replay_detection + ai_type + authentication_information)
                # options in answer to be logged
                options_answer.append(11)

            # Option 12 Server Unicast Option
            if 12 in options_request:
                response_ascii += build_option(12, binascii.b2a_hex(socket.inet_pton(socket.AF_INET6, cfg.ADDRESS)))
                # options in answer to be logged
                options_answer.append(12)

            # Option 13 Status Code Option - statuscode is taken from dictionary
            if 13 in options_request:
                response_ascii += build_option(13, '%04x' % (status))
                # options in answer to be logged
                options_answer.append(13)

            # Option 14 Rapid Commit Option - necessary for REPLY to SOLICIT message with Rapid Commit
            if 14 in options_request:
                response_ascii += build_option(14, '')
                # options in answer to be logged
                options_answer.append(14)

            # Option 23 DNS recursive name server
            if 23 in options_request:
                # should not be necessary to check if Transactions[transaction_id].Client exists but there are
                # crazy clients out in the wild which might become silent this way
                if Transactions[transaction_id].Client:
                    if len(cfg.CLASSES[Transactions[transaction_id].Client.Class].NAMESERVER) > 0:
                        nameserver = ''
                        for ns in cfg.CLASSES[Transactions[transaction_id].Client.Class].NAMESERVER:
                            nameserver += socket.inet_pton(socket.AF_INET6, ns)
                        response_ascii += build_option(23, binascii.b2a_hex(nameserver))
                        # options in answer to be logged
                        options_answer.append(23)

                elif len(cfg.NAMESERVER) > 0:
                    # in case several nameservers are given convert them all and add them
                    nameserver = ''
                    for ns in cfg.NAMESERVER:
                        nameserver += socket.inet_pton(socket.AF_INET6, ns)
                    response_ascii += build_option(23, binascii.b2a_hex(nameserver))
                    # options in answer to be logged
                    options_answer.append(23)

            # Option 24 Domain Search List
            if 24 in options_request:
                converted_domain_search_list = ''
                for d in cfg.DOMAIN_SEARCH_LIST:
                    converted_domain_search_list += convert_dns_to_binary(d)
                response_ascii += build_option(24, converted_domain_search_list)
                # options in answer to be logged
                options_answer.append(24)

            # Option 25 Prefix Delegation
            if 25 in options_request:
                # check if MAC of LLIP is really known
                if Transactions[transaction_id].ClientLLIP in CollectedMACs or cfg.IGNORE_MAC:
                    # collect client information
                    if Transactions[transaction_id].Client == None:
                        Transactions[transaction_id].Client = build_client(transaction_id)

                    # Only if prefixes are provided
                    if 'prefixes' in cfg.CLASSES[Transactions[transaction_id].Client.Class].ADVERTISE:
                        # check if only a short NoPrefixAvail answer or none at all is to be returned
                        if not Transactions[transaction_id].Answer == 'normal':
                            if Transactions[transaction_id].Answer == 'noprefix':
                                # Option 13 Status Code Option - statuscode is 6: 'No Prefix available'
                                response_ascii += build_option(13, '%04x' % (6))
                                # clean client prefixes which not be deployed anyway
                                Transactions[transaction_id].Client.Prefixes[:] = []
                                # options in answer to be logged
                                options_answer.append(13)
                            else:
                                # clean response as there is nothing to respond in case of answer = none
                                self.response = ''
                                return None
                        else:
                            # if client could not be built because of database problems send
                            # status message back
                            if Transactions[transaction_id].Client:
                                # embed option 26 into option 25 - several if necessary
                                ia_prefixes = ''
                                try:
                                    for prefix in Transactions[transaction_id].Client.Prefixes:
                                        ipv6_prefix = binascii.b2a_hex(socket.inet_pton(socket.AF_INET6,
                                                                                        colonify_ip6(prefix.PREFIX)))
                                        if prefix.VALID == True:
                                            preferred_lifetime = '%08x' % (int(prefix.PREFERRED_LIFETIME))
                                            valid_lifetime = '%08x' % (int(prefix.VALID_LIFETIME))
                                        else:
                                            preferred_lifetime = '%08x' % (0)
                                            valid_lifetime = '%08x' % (0)
                                        length = '%02x' % (int(prefix.LENGTH))
                                        ia_prefixes += build_option(26, preferred_lifetime + valid_lifetime + length + ipv6_prefix)

                                    if Transactions[transaction_id].Client.Class != '':
                                        t1 = '%08x' % (int(cfg.CLASSES[Transactions[transaction_id].Client.Class].T1))
                                        t2 = '%08x' % (int(cfg.CLASSES[Transactions[transaction_id].Client.Class].T2))
                                    else:
                                        t1 = '%08x' % (int(cfg.T1))
                                        t2 = '%08x' % (int(cfg.T2))

                                    # even if there anre no prefixes server has to deliver an empty PD
                                    response_ascii += build_option(25, Transactions[transaction_id].IAID + t1 + t2 + ia_prefixes)
                                    # if no prefixes available a NoPrefixAvail status code has to be sent
                                    if ia_prefixes == '':
                                        # REBIND not possible
                                        if Transactions[transaction_id].LastMessageReceivedType == 6:
                                            # Option 13 Status Code Option - statuscode is 3: 'NoBinding'
                                            response_ascii += build_option(13, '%04x' % (3))
                                        else:
                                            # Option 13 Status Code Option - statuscode is 6: 'No Prefix available'
                                            response_ascii += build_option(13, '%04x' % (6))
                                    # options in answer to be logged
                                    options_answer.append(25)

                                except Exception as err:
                                    print(err)
                                    # Option 13 Status Code Option - statuscode is 6: 'No Prefix available'
                                    response_ascii += build_option(13, '%04x' % (6))
                                    # options in answer to be logged
                                    options_answer.append(25)
                            else:
                                # Option 13 Status Code Option - statuscode is 6: 'No Prefix available'
                                response_ascii += build_option(13, '%04x' % (6))
                                # options in answer to be logged
                                options_answer.append(25)

            # Option 31 OPTION_SNTP_SERVERS
            if 31 in options_request and cfg.SNTP_SERVERS != '':
                sntp_servers = ''
                for s in cfg.SNTP_SERVERS:
                    sntp_server = binascii.b2a_hex(socket.inet_pton(socket.AF_INET6, s))
                    sntp_servers += sntp_server
                response_ascii += build_option(31, sntp_servers)

            # Option 32 Information Refresh Time
            if 32 in options_request:
                response_ascii += build_option(32, '%08x' % int(cfg.INFORMATION_REFRESH_TIME))
                # options in answer to be logged
                options_answer.append(32)

            # Option 39 FQDN
            # http://tools.ietf.org/html/rfc4704#page-5
            # regarding RFC 4704 5. there are 3 kinds of client behaviour for N O S:
            # - client wants to update DNS itself -> sends 0 0 0
            # - client wants server to update DNS -> sends 0 0 1
            # - client wants no server DNS update -> sends 1 0 0
            if 39 in options_request and Transactions[transaction_id].Client:
                # flags for answer
                N, O, S = 0, 0, 0
                # use hostname supplied by client
                if cfg.DNS_USE_CLIENT_HOSTNAME:
                    hostname = Transactions[transaction_id].Hostname
                # use hostname from config
                else:
                    hostname = Transactions[transaction_id].Client.Hostname
                if not hostname == '':
                    if cfg.DNS_UPDATE == 1:
                        # DNS update done by server - don't care what client wants
                        if cfg.DNS_IGNORE_CLIENT:
                            S = 1
                            O = 1
                        else:
                            # honor the client's request for the server to initiate DNS updates
                            if Transactions[transaction_id].DNS_S == 1:
                                S = 1
                            # honor the client's request for no server-initiated DNS update
                            elif  Transactions[transaction_id].DNS_N == 1:
                                N = 1
                    else:
                        # no DNS update at all, not for server and not for client
                        if Transactions[transaction_id].DNS_N == 1 or\
                           Transactions[transaction_id].DNS_S == 1:
                            O = 1

                    # sum of flags
                    nos_flags = N*4 + O*2 + S*1

                    response_ascii += build_option(39, '%02x' % (nos_flags) + convert_dns_to_binary(hostname + '.' + cfg.DOMAIN))
                else:
                    # if no hostname given put something in and force client override
                    response_ascii += build_option(39, '%02x' % (3) + convert_dns_to_binary('invalid-hostname'))
                # options in answer to be logged
                options_answer.append(39)

            # Option 56 NTP server
            # https://tools.ietf.org/html/rfc5908
            if 56 in options_request:
                ntp_server_options = ''
                if len(cfg.NTP_SERVER) > 0:
                    for ntp_server_type in list(cfg.NTP_SERVER_dict.keys()):
                        # ntp_server_suboption
                        for ntp_server in cfg.NTP_SERVER_dict[ntp_server_type]:
                            ntp_server_suboption = ''
                            if ntp_server_type == 'SRV':
                                ntp_server_suboption = build_option(1, binascii.b2a_hex(socket.inet_pton(socket.AF_INET6, ntp_server)))
                            elif ntp_server_type == 'MC':
                                ntp_server_suboption = build_option(2, binascii.b2a_hex(socket.inet_pton(socket.AF_INET6, ntp_server)))
                            elif ntp_server_type == 'FQDN':
                                ntp_server_suboption = build_option(3, convert_dns_to_binary(ntp_server))
                            ntp_server_options += ntp_server_suboption
                    response_ascii += build_option(56, ntp_server_options)
                    # options in answer to be logged
                    options_answer.append(56)

            # Option 59 Network Boot
            # https://tools.ietf.org/html/rfc5970
            if 59 in options_request:
                # build client if not done yet
                if Transactions[transaction_id].Client == None:
                    Transactions[transaction_id].Client = build_client(transaction_id)

                bootfiles = Transactions[transaction_id].Client.Bootfiles
                if len(bootfiles) > 0:
                    # TODO add preference logic
                    bootfile_url = bootfiles[0].BOOTFILE_URL
                    Transactions[transaction_id].Client.ChosenBootFile = bootfile_url
                    bootfile_options = binascii.b2a_hex(bootfile_url)
                    response_ascii += build_option(59, bootfile_options)
                    # options in answer to be logged
                    options_answer.append(59)

            # if databases are not connected send error to client
            if not (configstore.connected == volatilestore.connected == True):
                # mark database errors - every database may add its error
                dberror = []
                if not configstore.connected:
                    dberror.append('config')
                    configstore.DBConnect()
                if not volatilestore.connected:
                    dberror.append('volatile')
                    volatilestore.DBConnect()

                # create error response - headers have to be recreated because
                # problems may have arisen while processing and these information
                # is not valid anymore
                # response type + transaction id
                response_ascii = '%02x' % (7)
                response_ascii += transaction_id

                # always of interest
                # option 1 client identifier
                response_ascii += build_option(1, Transactions[transaction_id].DUID)
                # option 2 server identifier
                response_ascii += build_option(2, cfg.SERVERDUID)

                # Option 13 Status Code Option - statuscode is 2: 'No Addresses available'
                response_ascii += build_option(13, '%04x' % (2))

                log.error('%s| TransactionID: %s | DatabaseError: %s' % (MESSAGE_TYPES[response_type], transaction_id, ' '.join(dberror)))

            else:
                # log response
                if not Transactions[transaction_id].Client is None:
                    if len(Transactions[transaction_id].Client.Addresses) == 0 and\
                       len(Transactions[transaction_id].Client.Prefixes) == 0 and\
                       Transactions[transaction_id].Answer == 'normal' and\
                       Transactions[transaction_id].LastMessageReceivedType in [1, 3, 5, 6]:
                        # create error response - headers have to be recreated because
                        # problems may have arisen while processing and these information
                        # is not valid anymore
                        # response type + transaction id
                        response_ascii = '%02x' % (7)
                        response_ascii += transaction_id

                        # always of interest
                        # option 1 client identifier
                        response_ascii += build_option(1, Transactions[transaction_id].DUID)
                        # option 2 server identifier
                        response_ascii += build_option(2, cfg.SERVERDUID)

                        # Option 13 Status Code Option - statuscode is 2: 'No Addresses available'
                        response_ascii += build_option(13, '%04x' % (2))
                        # options in answer to be logged
                        options_answer.append(13)

                        # log warning message about unavailable addresses
                        log.warning('REPLY | No addresses or prefixes available | TransactionID: %s | ClientLLIP: %s' % \
                                    (transaction_id, colonify_ip6(Transactions[transaction_id].ClientLLIP)))

                    elif 3 in options_request or 4 in options_request or 13 in options_request or 25 in options_request:
                        # options_answer.sort()
                        options_answer = sorted(options_answer)
                        log.info('%s | TransactionID: %s | Options: %s%s' % (MESSAGE_TYPES[response_type], transaction_id, options_answer, Transactions[transaction_id].Client._get_options_string()))
                    else:
                        print(options_request)
                        log.info('what else should I do?')
                else:
                    # options_answer.sort()
                    options_answer = sorted(options_answer)
                    log.info('%s | TransactionID: %s | Options: %s' % (MESSAGE_TYPES[response_type], transaction_id, options_answer))

            # response
            self.response = binascii.a2b_hex(response_ascii)

        except Exception as err:
            traceback.print_exc(file=sys.stdout)
            sys.stdout.flush()
            log.error('Response(): ' + str(err))
            print(transaction_id)
            print(Transactions[transaction_id].Client.__dict__)

            # clear any response
            self.response = ''

            return None


    def finish(self):
        """
            send response from self.response
        """
        # send only if there is anything to send
        if cfg.REALLY_DO_IT:
            if len(self.response) > 0:
                self.socket.sendto(self.response, self.client_address)
        else:
            log.error("Nothing sent - please set 'really_do_it = yes' in config file or as command line option.")


    def control_message(self, raw_bytes):
        """
            execute commands sent in by control message
        """
        control_message = binascii.unhexlify(raw_bytes)
        control_message_fragments = control_message.split(' ')
        # clean message
        control_message_clean = list()
        for count in range(len(control_message_fragments)):
            if control_message_fragments[count] != '':
                control_message_clean.append(control_message_fragments[count])
        command = control_message_clean[0]
        arguments = control_message_clean[1:]

        # change dynamic prefix
        if command == 'prefix' and len(arguments) == 1:
            cfg.PREFIX = arguments[0]
            volatilestore.store_dynamic_prefix(cfg.PREFIX)
        log.info('Control message "%s" received' % ' '.join(control_message_clean))


### MAIN ###

if __name__ == '__main__':
    log.info('Starting dhcpy6d daemon...')
    log.info('Server DUID: %s' % (cfg.SERVERDUID))

    # configure SocketServer
    UDPMulticastIPv6.address_family = socket.AF_INET6
    server = UDPMulticastIPv6(('', 547), Handler)

    # start query queue watcher
    configquery_queue_watcher = QueryQueue(cfg, configstore, configquery_queue, configanswer_queue)
    configquery_queue_watcher.start()
    volatilequery_queue_watcher = QueryQueue(cfg, volatilestore, volatilequery_queue, volatileanswer_queue)
    volatilequery_queue_watcher.start()

    # if global dynamic prefix was not given take it from database - only possible after database initialisation
    if cfg.PREFIX == '':
        cfg.PREFIX = volatilestore.get_dynamic_prefix()
    if cfg.PREFIX == None:
        cfg.PREFIX = ''

    # apply dynamic prefix to addresses and prefixes
    for a in cfg.ADDRESSES:
        cfg.ADDRESSES[a].inject_dynamic_prefix_into_prototype(cfg.PREFIX)
    for p in cfg.PREFIXES:
        cfg.PREFIXES[p].inject_dynamic_prefix_into_prototype(cfg.PREFIX)

    # adjust old data to match newer versions of dhcpy6d
    volatilestore.LegacyAdjustments()

    # collect all known MAC addresses from database
    if cfg.CACHE_MAC_LLIP == True:
        volatilestore.CollectMACsFromDB()

    # start timer
    timer_thread = TimerThread()
    timer_thread.start()

    # start route queue to care for routes in background
    route_thread = RouteThread(route_queue)
    route_thread.start()

    # delete invalid and add valid routes - useful after reboot
    if cfg.MANAGE_ROUTES_AT_START:
        manage_prefixes_routes()

    # start TidyUp thread for cleaning in background
    tidyup_thread = TidyUpThread()
    tidyup_thread.start()

    # start DNS query queue to care for DNS in background
    dnsquery_thread = DNSQueryThread(dnsquery_queue)
    dnsquery_thread.start()

    # set user and group
    log.info('Running as user %s (UID %s) and group %s (GID %s)' % (cfg.USER, pwd.getpwnam(cfg.USER).pw_uid, cfg.GROUP, grp.getgrnam(cfg.GROUP).gr_gid))
    # first set group because otherwise the freshly unprivileged user could not modify its groups itself
    os.setgid(grp.getgrnam(cfg.GROUP).gr_gid)
    os.setuid(pwd.getpwnam(cfg.USER).pw_uid)

    # log interfaces
    log.info('Listening on interfaces: %s' % (' '.join(IF_NAME)))

    # serve forever
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        sys.exit(0)
